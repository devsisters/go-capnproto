// Code generated by github.com/devsisters/go-capnproto - DO NOT EDIT.

package aircraftlib

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	C "github.com/devsisters/go-capnproto"
	"io"
	"math"
	"net"
)

type Zdate C.Struct

func NewZdate(s *C.Segment) Zdate      { return Zdate(s.NewStruct(8, 0)) }
func NewRootZdate(s *C.Segment) Zdate  { return Zdate(s.NewRootStruct(8, 0)) }
func AutoNewZdate(s *C.Segment) Zdate  { return Zdate(s.NewStructAR(8, 0)) }
func ReadRootZdate(s *C.Segment) Zdate { return Zdate(s.Root(0).ToStruct()) }
func (s Zdate) Year() int16            { return int16(C.Struct(s).Get16(0)) }
func (s Zdate) SetYear(v int16)        { C.Struct(s).Set16(0, uint16(v)) }
func (s Zdate) Month() uint8           { return C.Struct(s).Get8(2) }
func (s Zdate) SetMonth(v uint8)       { C.Struct(s).Set8(2, v) }
func (s Zdate) Day() uint8             { return C.Struct(s).Get8(3) }
func (s Zdate) SetDay(v uint8)         { C.Struct(s).Set8(3, v) }

type Zdate_List C.PointerList

func NewZdateList(s *C.Segment, sz int) Zdate_List { return Zdate_List(s.NewCompositeList(8, 0, sz)) }
func (s Zdate_List) Len() int                      { return C.PointerList(s).Len() }
func (s Zdate_List) At(i int) Zdate                { return Zdate(C.PointerList(s).At(i).ToStruct()) }
func (s Zdate_List) ToArray() []Zdate {
	n := s.Len()
	a := make([]Zdate, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Zdate_List) Set(i int, item Zdate) { C.PointerList(s).Set(i, C.Object(item)) }

type Zdate_Struct struct {
	Year  int16
	Month uint8
	Day   uint8
}

func (s Zdate) Struct() *Zdate_Struct {
	t := &Zdate_Struct{}
	t.Year = s.Year()
	t.Month = s.Month()
	t.Day = s.Day()
	return t
}
func (s Zdate) LoadStruct(t *Zdate_Struct) {
	if t == nil {
		return
	}
	s.SetYear(t.Year)
	s.SetMonth(t.Month)
	s.SetDay(t.Day)
}
func (s *Zdate_Struct) Copy() *Zdate_Struct {
	t := &Zdate_Struct{}
	t.Year = s.Year
	t.Month = s.Month
	t.Day = s.Day
	return t
}
func (s *Zdate_Struct) Capnp(seg *C.Segment) Zdate {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewZdate(seg)
	t.LoadStruct(s)
	return t
}
func (s *Zdate_Struct) RootCapnp(seg *C.Segment) Zdate {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootZdate(seg)
	t.LoadStruct(s)
	return t
}
func (s Zdate) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"year\":")
		if err != nil {
			return err
		}
		{
			s := s.Year()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"month\":")
		if err != nil {
			return err
		}
		{
			s := s.Month()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"day\":")
		if err != nil {
			return err
		}
		{
			s := s.Day()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zdate) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Zdate) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("year = ")
	if err != nil {
		return err
	}
	{
		s := s.Year()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("month = ")
	if err != nil {
		return err
	}
	{
		s := s.Month()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("day = ")
	if err != nil {
		return err
	}
	{
		s := s.Day()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zdate) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewZdateFromCapLit(s *C.Segment, b []byte) (p Zdate, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewZdate(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootZdateFromCapLit(s *C.Segment, b []byte) (p Zdate, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootZdate(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Zdate) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["year"]; ok {
		_ = fn
		var t int16
		if temp, ok := fn.Val.(int64); ok {
			t = int16(temp)
		} else {
			return fmt.Errorf("expected 'int16' but didn't matched")
		}
		_ = t
		s.SetYear(t)
	}
	if fn, ok := sv["month"]; ok {
		_ = fn
		var t uint8
		if temp, ok := fn.Val.(int64); ok {
			t = uint8(temp)
		} else {
			return fmt.Errorf("expected 'uint8' but didn't matched")
		}
		_ = t
		s.SetMonth(t)
	}
	if fn, ok := sv["day"]; ok {
		_ = fn
		var t uint8
		if temp, ok := fn.Val.(int64); ok {
			t = uint8(temp)
		} else {
			return fmt.Errorf("expected 'uint8' but didn't matched")
		}
		_ = t
		s.SetDay(t)
	}
	return err
}
func (s Zdate_List) FilterIndex(f func(i int, x Zdate) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Zdate_List) Each(f func(i int, x Zdate) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Zdate_List) Find(f func(i int, x Zdate) bool) (Zdate, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Zdate{}, false
}
func (s Zdate) Seg() *C.Segment {
	return s.Segment
}
func (s Zdate) LitName() string {
	return "Zdate"
}

type Zdata C.Struct

func NewZdata(s *C.Segment) Zdata      { return Zdata(s.NewStruct(0, 1)) }
func NewRootZdata(s *C.Segment) Zdata  { return Zdata(s.NewRootStruct(0, 1)) }
func AutoNewZdata(s *C.Segment) Zdata  { return Zdata(s.NewStructAR(0, 1)) }
func ReadRootZdata(s *C.Segment) Zdata { return Zdata(s.Root(0).ToStruct()) }
func (s Zdata) Data() []byte           { return C.Struct(s).GetObject(0).ToData() }
func (s Zdata) SetData(v []byte)       { C.Struct(s).SetObject(0, s.Segment.NewData(v)) }

type Zdata_List C.PointerList

func NewZdataList(s *C.Segment, sz int) Zdata_List { return Zdata_List(s.NewCompositeList(0, 1, sz)) }
func (s Zdata_List) Len() int                      { return C.PointerList(s).Len() }
func (s Zdata_List) At(i int) Zdata                { return Zdata(C.PointerList(s).At(i).ToStruct()) }
func (s Zdata_List) ToArray() []Zdata {
	n := s.Len()
	a := make([]Zdata, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Zdata_List) Set(i int, item Zdata) { C.PointerList(s).Set(i, C.Object(item)) }

type Zdata_Struct struct {
	Data []byte
}

func (s Zdata) Struct() *Zdata_Struct {
	t := &Zdata_Struct{}
	t.Data = s.Data()
	return t
}
func (s Zdata) LoadStruct(t *Zdata_Struct) {
	if t == nil {
		return
	}
	s.SetData(t.Data)
}
func (s *Zdata_Struct) Copy() *Zdata_Struct {
	t := &Zdata_Struct{}
	t.Data = s.Data
	return t
}
func (s *Zdata_Struct) Capnp(seg *C.Segment) Zdata {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewZdata(seg)
	t.LoadStruct(s)
	return t
}
func (s *Zdata_Struct) RootCapnp(seg *C.Segment) Zdata {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootZdata(seg)
	t.LoadStruct(s)
	return t
}
func (s Zdata) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"data\":")
		if err != nil {
			return err
		}
		{
			s := s.Data()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zdata) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Zdata) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("data = ")
	if err != nil {
		return err
	}
	{
		s := s.Data()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zdata) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewZdataFromCapLit(s *C.Segment, b []byte) (p Zdata, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewZdata(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootZdataFromCapLit(s *C.Segment, b []byte) (p Zdata, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootZdata(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Zdata) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["data"]; ok {
		_ = fn
		var t []byte
		if temp, ok := fn.Val.(string); ok {
			t = []byte(temp)
		} else {
			return fmt.Errorf("expected '[]byte' but didn't matched")
		}
		_ = t
		s.SetData(t)
	}
	return err
}
func (s Zdata_List) FilterIndex(f func(i int, x Zdata) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Zdata_List) Each(f func(i int, x Zdata) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Zdata_List) Find(f func(i int, x Zdata) bool) (Zdata, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Zdata{}, false
}
func (s Zdata) Seg() *C.Segment {
	return s.Segment
}
func (s Zdata) LitName() string {
	return "Zdata"
}

type Airport uint16

const (
	AIRPORT_NONE Airport = 0
	AIRPORT_JFK  Airport = 1
	AIRPORT_LAX  Airport = 2
	AIRPORT_SFO  Airport = 3
	AIRPORT_LUV  Airport = 4
	AIRPORT_DFW  Airport = 5
	AIRPORT_TEST Airport = 6
)

func (c Airport) String() string {
	switch c {
	case AIRPORT_NONE:
		return "none"
	case AIRPORT_JFK:
		return "jfk"
	case AIRPORT_LAX:
		return "lax"
	case AIRPORT_SFO:
		return "sfo"
	case AIRPORT_LUV:
		return "luv"
	case AIRPORT_DFW:
		return "dfw"
	case AIRPORT_TEST:
		return "test"
	default:
		return ""
	}
}

func AirportFromString(c string) Airport {
	switch c {
	case "none":
		return AIRPORT_NONE
	case "jfk":
		return AIRPORT_JFK
	case "lax":
		return AIRPORT_LAX
	case "sfo":
		return AIRPORT_SFO
	case "luv":
		return AIRPORT_LUV
	case "dfw":
		return AIRPORT_DFW
	case "test":
		return AIRPORT_TEST
	default:
		return 0
	}
}

type Airport_List C.PointerList

func NewAirportList(s *C.Segment, sz int) Airport_List { return Airport_List(s.NewUInt16List(sz)) }
func (s Airport_List) Len() int                        { return C.UInt16List(s).Len() }
func (s Airport_List) At(i int) Airport                { return Airport(C.UInt16List(s).At(i)) }
func (s Airport_List) ToArray() []Airport {
	n := s.Len()
	a := make([]Airport, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Airport_List) Set(i int, item Airport) { C.UInt16List(s).Set(i, uint16(item)) }
func (s Airport) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	buf, err = json.Marshal(s.String())
	if err != nil {
		return err
	}
	_, err = b.Write(buf)
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Airport) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Airport) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	_, err = b.WriteString(s.String())
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Airport) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func AirportFromCapLit(b []byte) (Airport, error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return Airport(0), err
	}
	ev, ok := n.Val.(string)
	if !ok {
		return Airport(0), fmt.Errorf("expected 'string' but didn't matched")
	}
	_ = ev
	return AirportFromString(ev), nil
}

type PlaneBase C.Struct

func NewPlaneBase(s *C.Segment) PlaneBase      { return PlaneBase(s.NewStruct(32, 2)) }
func NewRootPlaneBase(s *C.Segment) PlaneBase  { return PlaneBase(s.NewRootStruct(32, 2)) }
func AutoNewPlaneBase(s *C.Segment) PlaneBase  { return PlaneBase(s.NewStructAR(32, 2)) }
func ReadRootPlaneBase(s *C.Segment) PlaneBase { return PlaneBase(s.Root(0).ToStruct()) }
func (s PlaneBase) Name() string               { return C.Struct(s).GetObject(0).ToText() }
func (s PlaneBase) NameBytes() []byte          { return C.Struct(s).GetObject(0).ToDataTrimLastByte() }
func (s PlaneBase) SetName(v string)           { C.Struct(s).SetObject(0, s.Segment.NewText(v)) }
func (s PlaneBase) Homes() Airport_List        { return Airport_List(C.Struct(s).GetObject(1)) }
func (s PlaneBase) SetHomes(v Airport_List)    { C.Struct(s).SetObject(1, C.Object(v)) }
func (s PlaneBase) Rating() int64              { return int64(C.Struct(s).Get64(0)) }
func (s PlaneBase) SetRating(v int64)          { C.Struct(s).Set64(0, uint64(v)) }
func (s PlaneBase) CanFly() bool               { return C.Struct(s).Get1(64) }
func (s PlaneBase) SetCanFly(v bool)           { C.Struct(s).Set1(64, v) }
func (s PlaneBase) Capacity() int64            { return int64(C.Struct(s).Get64(16)) }
func (s PlaneBase) SetCapacity(v int64)        { C.Struct(s).Set64(16, uint64(v)) }
func (s PlaneBase) MaxSpeed() float64          { return math.Float64frombits(C.Struct(s).Get64(24)) }
func (s PlaneBase) SetMaxSpeed(v float64)      { C.Struct(s).Set64(24, math.Float64bits(v)) }

type PlaneBase_List C.PointerList

func NewPlaneBaseList(s *C.Segment, sz int) PlaneBase_List {
	return PlaneBase_List(s.NewCompositeList(32, 2, sz))
}
func (s PlaneBase_List) Len() int           { return C.PointerList(s).Len() }
func (s PlaneBase_List) At(i int) PlaneBase { return PlaneBase(C.PointerList(s).At(i).ToStruct()) }
func (s PlaneBase_List) ToArray() []PlaneBase {
	n := s.Len()
	a := make([]PlaneBase, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s PlaneBase_List) Set(i int, item PlaneBase) { C.PointerList(s).Set(i, C.Object(item)) }

type PlaneBase_Struct struct {
	Name     string
	Homes    []Airport
	Rating   int64
	CanFly   bool
	Capacity int64
	MaxSpeed float64
}

func (s PlaneBase) Struct() *PlaneBase_Struct {
	t := &PlaneBase_Struct{}
	t.Name = s.Name()
	for i := 0; i < s.Homes().Len(); i++ {
		t.Homes = append(t.Homes, s.Homes().At(i))
	}
	t.Rating = s.Rating()
	t.CanFly = s.CanFly()
	t.Capacity = s.Capacity()
	t.MaxSpeed = s.MaxSpeed()
	return t
}
func (s PlaneBase) LoadStruct(t *PlaneBase_Struct) {
	if t == nil {
		return
	}
	s.SetName(t.Name)
	s.SetHomes(NewAirportList(s.Segment, len(t.Homes)))
	for i := 0; i < len(t.Homes); i++ {
		s.Homes().Set(i, t.Homes[i])
	}
	s.SetRating(t.Rating)
	s.SetCanFly(t.CanFly)
	s.SetCapacity(t.Capacity)
	s.SetMaxSpeed(t.MaxSpeed)
}
func (s *PlaneBase_Struct) Copy() *PlaneBase_Struct {
	t := &PlaneBase_Struct{}
	t.Name = s.Name
	for _, e := range s.Homes {
		t.Homes = append(t.Homes, e)
	}
	t.Rating = s.Rating
	t.CanFly = s.CanFly
	t.Capacity = s.Capacity
	t.MaxSpeed = s.MaxSpeed
	return t
}
func (s *PlaneBase_Struct) Capnp(seg *C.Segment) PlaneBase {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewPlaneBase(seg)
	t.LoadStruct(s)
	return t
}
func (s *PlaneBase_Struct) RootCapnp(seg *C.Segment) PlaneBase {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootPlaneBase(seg)
	t.LoadStruct(s)
	return t
}
func (s PlaneBase) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"name\":")
		if err != nil {
			return err
		}
		{
			s := s.Name()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"homes\":")
		if err != nil {
			return err
		}
		{
			s := s.Homes()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"rating\":")
		if err != nil {
			return err
		}
		{
			s := s.Rating()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"canFly\":")
		if err != nil {
			return err
		}
		{
			s := s.CanFly()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"capacity\":")
		if err != nil {
			return err
		}
		{
			s := s.Capacity()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"maxSpeed\":")
		if err != nil {
			return err
		}
		{
			s := s.MaxSpeed()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s PlaneBase) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s PlaneBase) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("name = ")
	if err != nil {
		return err
	}
	{
		s := s.Name()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("homes = ")
	if err != nil {
		return err
	}
	{
		s := s.Homes()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("rating = ")
	if err != nil {
		return err
	}
	{
		s := s.Rating()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("canFly = ")
	if err != nil {
		return err
	}
	{
		s := s.CanFly()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("capacity = ")
	if err != nil {
		return err
	}
	{
		s := s.Capacity()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("maxSpeed = ")
	if err != nil {
		return err
	}
	{
		s := s.MaxSpeed()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s PlaneBase) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewPlaneBaseFromCapLit(s *C.Segment, b []byte) (p PlaneBase, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewPlaneBase(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootPlaneBaseFromCapLit(s *C.Segment, b []byte) (p PlaneBase, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootPlaneBase(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s PlaneBase) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["name"]; ok {
		_ = fn
		t, ok := fn.Val.(string)
		if !ok {
			return fmt.Errorf("expected 'string' but didn't matched")
		}
		_ = t
		s.SetName(t)
	}
	if fn, ok := sv["homes"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewAirportList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			var ev Airport
			sEv, ok := en.Val.(string)
			if !ok {
				return fmt.Errorf("expected 'string' but didn't matched")
			}
			_ = sEv
			ev = AirportFromString(sEv)
			t.Set(i, ev)
		}
		s.SetHomes(t)
	}
	if fn, ok := sv["rating"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetRating(t)
	}
	if fn, ok := sv["canFly"]; ok {
		_ = fn
		t, ok := fn.Val.(bool)
		if !ok {
			return fmt.Errorf("expected 'bool' but didn't matched")
		}
		_ = t
		s.SetCanFly(t)
	}
	if fn, ok := sv["capacity"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetCapacity(t)
	}
	if fn, ok := sv["maxSpeed"]; ok {
		_ = fn
		var t float64
		if temp, ok := fn.Val.(float64); ok {
			t = float64(temp)
		} else {
			return fmt.Errorf("expected 'float64' but didn't matched")
		}
		_ = t
		s.SetMaxSpeed(t)
	}
	return err
}
func (s PlaneBase_List) FilterIndex(f func(i int, x PlaneBase) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s PlaneBase_List) Each(f func(i int, x PlaneBase) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s PlaneBase_List) Find(f func(i int, x PlaneBase) bool) (PlaneBase, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return PlaneBase{}, false
}
func (s PlaneBase) Seg() *C.Segment {
	return s.Segment
}
func (s PlaneBase) LitName() string {
	return "PlaneBase"
}

type B737 C.Struct

func NewB737(s *C.Segment) B737      { return B737(s.NewStruct(0, 1)) }
func NewRootB737(s *C.Segment) B737  { return B737(s.NewRootStruct(0, 1)) }
func AutoNewB737(s *C.Segment) B737  { return B737(s.NewStructAR(0, 1)) }
func ReadRootB737(s *C.Segment) B737 { return B737(s.Root(0).ToStruct()) }
func (s B737) Base() PlaneBase       { return PlaneBase(C.Struct(s).GetObject(0).ToStruct()) }
func (s B737) SetBase(v PlaneBase)   { C.Struct(s).SetObject(0, C.Object(v)) }

type B737_List C.PointerList

func NewB737List(s *C.Segment, sz int) B737_List { return B737_List(s.NewCompositeList(0, 1, sz)) }
func (s B737_List) Len() int                     { return C.PointerList(s).Len() }
func (s B737_List) At(i int) B737                { return B737(C.PointerList(s).At(i).ToStruct()) }
func (s B737_List) ToArray() []B737 {
	n := s.Len()
	a := make([]B737, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s B737_List) Set(i int, item B737) { C.PointerList(s).Set(i, C.Object(item)) }

type B737_Struct struct {
	Base *PlaneBase_Struct
}

func (s B737) Struct() *B737_Struct {
	t := &B737_Struct{}
	{
		t.Base = s.Base().Struct()
	}
	return t
}
func (s B737) LoadStruct(t *B737_Struct) {
	if t == nil {
		return
	}
	{
		p := NewPlaneBase(s.Segment)
		p.LoadStruct(t.Base)
		s.SetBase(p)
	}
}
func (s *B737_Struct) Copy() *B737_Struct {
	t := &B737_Struct{}
	if s.Base != nil {
		t.Base = s.Base.Copy()
	}
	return t
}
func (s *B737_Struct) Capnp(seg *C.Segment) B737 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewB737(seg)
	t.LoadStruct(s)
	return t
}
func (s *B737_Struct) RootCapnp(seg *C.Segment) B737 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootB737(seg)
	t.LoadStruct(s)
	return t
}
func (s B737) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"base\":")
		if err != nil {
			return err
		}
		{
			s := s.Base()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s B737) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s B737) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("base = ")
	if err != nil {
		return err
	}
	{
		s := s.Base()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s B737) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewB737FromCapLit(s *C.Segment, b []byte) (p B737, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewB737(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootB737FromCapLit(s *C.Segment, b []byte) (p B737, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootB737(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s B737) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["base"]; ok {
		_ = fn
		t := NewPlaneBase(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetBase(t)
	}
	return err
}
func (s B737_List) FilterIndex(f func(i int, x B737) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s B737_List) Each(f func(i int, x B737) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s B737_List) Find(f func(i int, x B737) bool) (B737, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return B737{}, false
}
func (s B737) Seg() *C.Segment {
	return s.Segment
}
func (s B737) LitName() string {
	return "B737"
}

type A320 C.Struct

func NewA320(s *C.Segment) A320      { return A320(s.NewStruct(0, 1)) }
func NewRootA320(s *C.Segment) A320  { return A320(s.NewRootStruct(0, 1)) }
func AutoNewA320(s *C.Segment) A320  { return A320(s.NewStructAR(0, 1)) }
func ReadRootA320(s *C.Segment) A320 { return A320(s.Root(0).ToStruct()) }
func (s A320) Base() PlaneBase       { return PlaneBase(C.Struct(s).GetObject(0).ToStruct()) }
func (s A320) SetBase(v PlaneBase)   { C.Struct(s).SetObject(0, C.Object(v)) }

type A320_List C.PointerList

func NewA320List(s *C.Segment, sz int) A320_List { return A320_List(s.NewCompositeList(0, 1, sz)) }
func (s A320_List) Len() int                     { return C.PointerList(s).Len() }
func (s A320_List) At(i int) A320                { return A320(C.PointerList(s).At(i).ToStruct()) }
func (s A320_List) ToArray() []A320 {
	n := s.Len()
	a := make([]A320, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s A320_List) Set(i int, item A320) { C.PointerList(s).Set(i, C.Object(item)) }

type A320_Struct struct {
	Base *PlaneBase_Struct
}

func (s A320) Struct() *A320_Struct {
	t := &A320_Struct{}
	{
		t.Base = s.Base().Struct()
	}
	return t
}
func (s A320) LoadStruct(t *A320_Struct) {
	if t == nil {
		return
	}
	{
		p := NewPlaneBase(s.Segment)
		p.LoadStruct(t.Base)
		s.SetBase(p)
	}
}
func (s *A320_Struct) Copy() *A320_Struct {
	t := &A320_Struct{}
	if s.Base != nil {
		t.Base = s.Base.Copy()
	}
	return t
}
func (s *A320_Struct) Capnp(seg *C.Segment) A320 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewA320(seg)
	t.LoadStruct(s)
	return t
}
func (s *A320_Struct) RootCapnp(seg *C.Segment) A320 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootA320(seg)
	t.LoadStruct(s)
	return t
}
func (s A320) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"base\":")
		if err != nil {
			return err
		}
		{
			s := s.Base()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s A320) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s A320) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("base = ")
	if err != nil {
		return err
	}
	{
		s := s.Base()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s A320) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewA320FromCapLit(s *C.Segment, b []byte) (p A320, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewA320(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootA320FromCapLit(s *C.Segment, b []byte) (p A320, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootA320(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s A320) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["base"]; ok {
		_ = fn
		t := NewPlaneBase(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetBase(t)
	}
	return err
}
func (s A320_List) FilterIndex(f func(i int, x A320) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s A320_List) Each(f func(i int, x A320) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s A320_List) Find(f func(i int, x A320) bool) (A320, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return A320{}, false
}
func (s A320) Seg() *C.Segment {
	return s.Segment
}
func (s A320) LitName() string {
	return "A320"
}

type F16 C.Struct

func NewF16(s *C.Segment) F16      { return F16(s.NewStruct(0, 1)) }
func NewRootF16(s *C.Segment) F16  { return F16(s.NewRootStruct(0, 1)) }
func AutoNewF16(s *C.Segment) F16  { return F16(s.NewStructAR(0, 1)) }
func ReadRootF16(s *C.Segment) F16 { return F16(s.Root(0).ToStruct()) }
func (s F16) Base() PlaneBase      { return PlaneBase(C.Struct(s).GetObject(0).ToStruct()) }
func (s F16) SetBase(v PlaneBase)  { C.Struct(s).SetObject(0, C.Object(v)) }

type F16_List C.PointerList

func NewF16List(s *C.Segment, sz int) F16_List { return F16_List(s.NewCompositeList(0, 1, sz)) }
func (s F16_List) Len() int                    { return C.PointerList(s).Len() }
func (s F16_List) At(i int) F16                { return F16(C.PointerList(s).At(i).ToStruct()) }
func (s F16_List) ToArray() []F16 {
	n := s.Len()
	a := make([]F16, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s F16_List) Set(i int, item F16) { C.PointerList(s).Set(i, C.Object(item)) }

type F16_Struct struct {
	Base *PlaneBase_Struct
}

func (s F16) Struct() *F16_Struct {
	t := &F16_Struct{}
	{
		t.Base = s.Base().Struct()
	}
	return t
}
func (s F16) LoadStruct(t *F16_Struct) {
	if t == nil {
		return
	}
	{
		p := NewPlaneBase(s.Segment)
		p.LoadStruct(t.Base)
		s.SetBase(p)
	}
}
func (s *F16_Struct) Copy() *F16_Struct {
	t := &F16_Struct{}
	if s.Base != nil {
		t.Base = s.Base.Copy()
	}
	return t
}
func (s *F16_Struct) Capnp(seg *C.Segment) F16 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewF16(seg)
	t.LoadStruct(s)
	return t
}
func (s *F16_Struct) RootCapnp(seg *C.Segment) F16 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootF16(seg)
	t.LoadStruct(s)
	return t
}
func (s F16) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"base\":")
		if err != nil {
			return err
		}
		{
			s := s.Base()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s F16) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s F16) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("base = ")
	if err != nil {
		return err
	}
	{
		s := s.Base()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s F16) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewF16FromCapLit(s *C.Segment, b []byte) (p F16, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewF16(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootF16FromCapLit(s *C.Segment, b []byte) (p F16, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootF16(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s F16) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["base"]; ok {
		_ = fn
		t := NewPlaneBase(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetBase(t)
	}
	return err
}
func (s F16_List) FilterIndex(f func(i int, x F16) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s F16_List) Each(f func(i int, x F16) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s F16_List) Find(f func(i int, x F16) bool) (F16, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return F16{}, false
}
func (s F16) Seg() *C.Segment {
	return s.Segment
}
func (s F16) LitName() string {
	return "F16"
}

type Regression C.Struct

func NewRegression(s *C.Segment) Regression      { return Regression(s.NewStruct(24, 3)) }
func NewRootRegression(s *C.Segment) Regression  { return Regression(s.NewRootStruct(24, 3)) }
func AutoNewRegression(s *C.Segment) Regression  { return Regression(s.NewStructAR(24, 3)) }
func ReadRootRegression(s *C.Segment) Regression { return Regression(s.Root(0).ToStruct()) }
func (s Regression) Base() PlaneBase             { return PlaneBase(C.Struct(s).GetObject(0).ToStruct()) }
func (s Regression) SetBase(v PlaneBase)         { C.Struct(s).SetObject(0, C.Object(v)) }
func (s Regression) B0() float64                 { return math.Float64frombits(C.Struct(s).Get64(0)) }
func (s Regression) SetB0(v float64)             { C.Struct(s).Set64(0, math.Float64bits(v)) }
func (s Regression) Beta() C.Float64List         { return C.Float64List(C.Struct(s).GetObject(1)) }
func (s Regression) SetBeta(v C.Float64List)     { C.Struct(s).SetObject(1, C.Object(v)) }
func (s Regression) Planes() Aircraft_List       { return Aircraft_List(C.Struct(s).GetObject(2)) }
func (s Regression) SetPlanes(v Aircraft_List)   { C.Struct(s).SetObject(2, C.Object(v)) }
func (s Regression) Ymu() float64                { return math.Float64frombits(C.Struct(s).Get64(8)) }
func (s Regression) SetYmu(v float64)            { C.Struct(s).Set64(8, math.Float64bits(v)) }
func (s Regression) Ysd() float64                { return math.Float64frombits(C.Struct(s).Get64(16)) }
func (s Regression) SetYsd(v float64)            { C.Struct(s).Set64(16, math.Float64bits(v)) }

type Regression_List C.PointerList

func NewRegressionList(s *C.Segment, sz int) Regression_List {
	return Regression_List(s.NewCompositeList(24, 3, sz))
}
func (s Regression_List) Len() int            { return C.PointerList(s).Len() }
func (s Regression_List) At(i int) Regression { return Regression(C.PointerList(s).At(i).ToStruct()) }
func (s Regression_List) ToArray() []Regression {
	n := s.Len()
	a := make([]Regression, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Regression_List) Set(i int, item Regression) { C.PointerList(s).Set(i, C.Object(item)) }

type Regression_Struct struct {
	Base   *PlaneBase_Struct
	B0     float64
	Beta   []float64
	Planes []*Aircraft_Struct
	Ymu    float64
	Ysd    float64
}

func (s Regression) Struct() *Regression_Struct {
	t := &Regression_Struct{}
	{
		t.Base = s.Base().Struct()
	}
	t.B0 = s.B0()
	for i := 0; i < s.Beta().Len(); i++ {
		t.Beta = append(t.Beta, s.Beta().At(i))
	}
	for i := 0; i < s.Planes().Len(); i++ {
		elem := s.Planes().At(i).Struct()
		t.Planes = append(t.Planes, elem)
	}
	t.Ymu = s.Ymu()
	t.Ysd = s.Ysd()
	return t
}
func (s Regression) LoadStruct(t *Regression_Struct) {
	if t == nil {
		return
	}
	{
		p := NewPlaneBase(s.Segment)
		p.LoadStruct(t.Base)
		s.SetBase(p)
	}
	s.SetB0(t.B0)
	s.SetBeta(s.Segment.NewFloat64List(len(t.Beta)))
	for i := 0; i < len(t.Beta); i++ {
		s.Beta().Set(i, t.Beta[i])
	}
	s.SetPlanes(NewAircraftList(s.Segment, len(t.Planes)))
	for i := 0; i < len(t.Planes); i++ {
		s.Planes().Set(i, t.Planes[i].Capnp(s.Segment))
	}
	s.SetYmu(t.Ymu)
	s.SetYsd(t.Ysd)
}
func (s *Regression_Struct) Copy() *Regression_Struct {
	t := &Regression_Struct{}
	if s.Base != nil {
		t.Base = s.Base.Copy()
	}
	t.B0 = s.B0
	for _, e := range s.Beta {
		t.Beta = append(t.Beta, e)
	}
	for _, e := range s.Planes {
		if e != nil {
			t.Planes = append(t.Planes, e.Copy())
		} else {
			t.Planes = append(t.Planes, nil)
		}
	}
	t.Ymu = s.Ymu
	t.Ysd = s.Ysd
	return t
}
func (s *Regression_Struct) Capnp(seg *C.Segment) Regression {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRegression(seg)
	t.LoadStruct(s)
	return t
}
func (s *Regression_Struct) RootCapnp(seg *C.Segment) Regression {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootRegression(seg)
	t.LoadStruct(s)
	return t
}
func (s Regression) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"base\":")
		if err != nil {
			return err
		}
		{
			s := s.Base()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"b0\":")
		if err != nil {
			return err
		}
		{
			s := s.B0()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"beta\":")
		if err != nil {
			return err
		}
		{
			s := s.Beta()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"planes\":")
		if err != nil {
			return err
		}
		{
			s := s.Planes()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ymu\":")
		if err != nil {
			return err
		}
		{
			s := s.Ymu()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ysd\":")
		if err != nil {
			return err
		}
		{
			s := s.Ysd()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Regression) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Regression) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("base = ")
	if err != nil {
		return err
	}
	{
		s := s.Base()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("b0 = ")
	if err != nil {
		return err
	}
	{
		s := s.B0()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("beta = ")
	if err != nil {
		return err
	}
	{
		s := s.Beta()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("planes = ")
	if err != nil {
		return err
	}
	{
		s := s.Planes()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("ymu = ")
	if err != nil {
		return err
	}
	{
		s := s.Ymu()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("ysd = ")
	if err != nil {
		return err
	}
	{
		s := s.Ysd()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Regression) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewRegressionFromCapLit(s *C.Segment, b []byte) (p Regression, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRegression(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootRegressionFromCapLit(s *C.Segment, b []byte) (p Regression, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootRegression(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Regression) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["base"]; ok {
		_ = fn
		t := NewPlaneBase(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetBase(t)
	}
	if fn, ok := sv["b0"]; ok {
		_ = fn
		var t float64
		if temp, ok := fn.Val.(float64); ok {
			t = float64(temp)
		} else {
			return fmt.Errorf("expected 'float64' but didn't matched")
		}
		_ = t
		s.SetB0(t)
	}
	if fn, ok := sv["beta"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewFloat64List(len(lv))
		for i, en := range lv {
			_ = en
			var ev float64
			if temp, ok := en.Val.(float64); ok {
				ev = float64(temp)
			} else {
				return fmt.Errorf("expected 'float64' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetBeta(t)
	}
	if fn, ok := sv["planes"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewAircraftList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewAircraft(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetPlanes(t)
	}
	if fn, ok := sv["ymu"]; ok {
		_ = fn
		var t float64
		if temp, ok := fn.Val.(float64); ok {
			t = float64(temp)
		} else {
			return fmt.Errorf("expected 'float64' but didn't matched")
		}
		_ = t
		s.SetYmu(t)
	}
	if fn, ok := sv["ysd"]; ok {
		_ = fn
		var t float64
		if temp, ok := fn.Val.(float64); ok {
			t = float64(temp)
		} else {
			return fmt.Errorf("expected 'float64' but didn't matched")
		}
		_ = t
		s.SetYsd(t)
	}
	return err
}
func (s Regression_List) FilterIndex(f func(i int, x Regression) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Regression_List) Each(f func(i int, x Regression) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Regression_List) Find(f func(i int, x Regression) bool) (Regression, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Regression{}, false
}
func (s Regression) Seg() *C.Segment {
	return s.Segment
}
func (s Regression) LitName() string {
	return "Regression"
}

type Aircraft C.Struct
type Aircraft_Which uint16

const (
	AIRCRAFT_VOID Aircraft_Which = 0
	AIRCRAFT_B737 Aircraft_Which = 1
	AIRCRAFT_A320 Aircraft_Which = 2
	AIRCRAFT_F16  Aircraft_Which = 3
)

func NewAircraft(s *C.Segment) Aircraft      { return Aircraft(s.NewStruct(8, 1)) }
func NewRootAircraft(s *C.Segment) Aircraft  { return Aircraft(s.NewRootStruct(8, 1)) }
func AutoNewAircraft(s *C.Segment) Aircraft  { return Aircraft(s.NewStructAR(8, 1)) }
func ReadRootAircraft(s *C.Segment) Aircraft { return Aircraft(s.Root(0).ToStruct()) }
func (s Aircraft) Which() Aircraft_Which     { return Aircraft_Which(C.Struct(s).Get16(0)) }
func (s Aircraft) SetVoid()                  { C.Struct(s).Set16(0, 0) }
func (s Aircraft) B737() B737                { return B737(C.Struct(s).GetObject(0).ToStruct()) }
func (s Aircraft) SetB737(v B737)            { C.Struct(s).Set16(0, 1); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Aircraft) A320() A320                { return A320(C.Struct(s).GetObject(0).ToStruct()) }
func (s Aircraft) SetA320(v A320)            { C.Struct(s).Set16(0, 2); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Aircraft) F16() F16                  { return F16(C.Struct(s).GetObject(0).ToStruct()) }
func (s Aircraft) SetF16(v F16)              { C.Struct(s).Set16(0, 3); C.Struct(s).SetObject(0, C.Object(v)) }

type Aircraft_List C.PointerList

func NewAircraftList(s *C.Segment, sz int) Aircraft_List {
	return Aircraft_List(s.NewCompositeList(8, 1, sz))
}
func (s Aircraft_List) Len() int          { return C.PointerList(s).Len() }
func (s Aircraft_List) At(i int) Aircraft { return Aircraft(C.PointerList(s).At(i).ToStruct()) }
func (s Aircraft_List) ToArray() []Aircraft {
	n := s.Len()
	a := make([]Aircraft, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Aircraft_List) Set(i int, item Aircraft) { C.PointerList(s).Set(i, C.Object(item)) }

type Aircraft_Struct struct {
	Which Aircraft_Which
	B737  *B737_Struct
	A320  *A320_Struct
	F16   *F16_Struct
}

func (s Aircraft) Struct() *Aircraft_Struct {
	t := &Aircraft_Struct{}
	t.Which = s.Which()
	if t.Which == AIRCRAFT_B737 {
		{
			t.B737 = s.B737().Struct()
		}
	}
	if t.Which == AIRCRAFT_A320 {
		{
			t.A320 = s.A320().Struct()
		}
	}
	if t.Which == AIRCRAFT_F16 {
		{
			t.F16 = s.F16().Struct()
		}
	}
	return t
}
func (s Aircraft) LoadStruct(t *Aircraft_Struct) {
	if t == nil {
		return
	}
	if t.Which == AIRCRAFT_VOID {
		s.SetVoid()
	}
	if t.Which == AIRCRAFT_B737 {
		{
			p := NewB737(s.Segment)
			p.LoadStruct(t.B737)
			s.SetB737(p)
		}
	}
	if t.Which == AIRCRAFT_A320 {
		{
			p := NewA320(s.Segment)
			p.LoadStruct(t.A320)
			s.SetA320(p)
		}
	}
	if t.Which == AIRCRAFT_F16 {
		{
			p := NewF16(s.Segment)
			p.LoadStruct(t.F16)
			s.SetF16(p)
		}
	}
}
func (s *Aircraft_Struct) Copy() *Aircraft_Struct {
	t := &Aircraft_Struct{}
	t.Which = s.Which
	if s.B737 != nil {
		t.B737 = s.B737.Copy()
	}
	if s.A320 != nil {
		t.A320 = s.A320.Copy()
	}
	if s.F16 != nil {
		t.F16 = s.F16.Copy()
	}
	return t
}
func (s *Aircraft_Struct) Capnp(seg *C.Segment) Aircraft {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewAircraft(seg)
	t.LoadStruct(s)
	return t
}
func (s *Aircraft_Struct) RootCapnp(seg *C.Segment) Aircraft {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootAircraft(seg)
	t.LoadStruct(s)
	return t
}
func (s Aircraft) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if s.Which() == AIRCRAFT_VOID {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"void\":")
			if err != nil {
				return err
			}
			_ = s
			_, err = b.WriteString("null")
			if err != nil {
				return err
			}
		}
		if s.Which() == AIRCRAFT_B737 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"b737\":")
			if err != nil {
				return err
			}
			{
				s := s.B737()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == AIRCRAFT_A320 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"a320\":")
			if err != nil {
				return err
			}
			{
				s := s.A320()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == AIRCRAFT_F16 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"f16\":")
			if err != nil {
				return err
			}
			{
				s := s.F16()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Aircraft) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Aircraft) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	if s.Which() == AIRCRAFT_VOID {
		_, err = b.WriteString("void = ")
		if err != nil {
			return err
		}
		_ = s
		_, err = b.WriteString("null")
		if err != nil {
			return err
		}
	}
	if s.Which() == AIRCRAFT_B737 {
		_, err = b.WriteString("b737 = ")
		if err != nil {
			return err
		}
		{
			s := s.B737()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == AIRCRAFT_A320 {
		_, err = b.WriteString("a320 = ")
		if err != nil {
			return err
		}
		{
			s := s.A320()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == AIRCRAFT_F16 {
		_, err = b.WriteString("f16 = ")
		if err != nil {
			return err
		}
		{
			s := s.F16()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Aircraft) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewAircraftFromCapLit(s *C.Segment, b []byte) (p Aircraft, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewAircraft(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootAircraftFromCapLit(s *C.Segment, b []byte) (p Aircraft, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootAircraft(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Aircraft) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["void"]; ok {
		_ = fn
		s.SetVoid()
	}
	if fn, ok := sv["b737"]; ok {
		_ = fn
		t := NewB737(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetB737(t)
	}
	if fn, ok := sv["a320"]; ok {
		_ = fn
		t := NewA320(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetA320(t)
	}
	if fn, ok := sv["f16"]; ok {
		_ = fn
		t := NewF16(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetF16(t)
	}
	return err
}
func (s Aircraft_List) FilterIndex(f func(i int, x Aircraft) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Aircraft_List) Each(f func(i int, x Aircraft) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Aircraft_List) Find(f func(i int, x Aircraft) bool) (Aircraft, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Aircraft{}, false
}
func (s Aircraft) Seg() *C.Segment {
	return s.Segment
}
func (s Aircraft) LitName() string {
	return "Aircraft"
}

type Z C.Struct
type Z_Which uint16

const (
	Z_VOID        Z_Which = 0
	Z_ZZ          Z_Which = 1
	Z_F64         Z_Which = 2
	Z_F32         Z_Which = 3
	Z_I64         Z_Which = 4
	Z_I32         Z_Which = 5
	Z_I16         Z_Which = 6
	Z_I8          Z_Which = 7
	Z_U64         Z_Which = 8
	Z_U32         Z_Which = 9
	Z_U16         Z_Which = 10
	Z_U8          Z_Which = 11
	Z_BOOL        Z_Which = 12
	Z_TEXT        Z_Which = 13
	Z_BLOB        Z_Which = 14
	Z_F64VEC      Z_Which = 15
	Z_F32VEC      Z_Which = 16
	Z_I64VEC      Z_Which = 17
	Z_I32VEC      Z_Which = 18
	Z_I16VEC      Z_Which = 19
	Z_I8VEC       Z_Which = 20
	Z_U64VEC      Z_Which = 21
	Z_U32VEC      Z_Which = 22
	Z_U16VEC      Z_Which = 23
	Z_U8VEC       Z_Which = 24
	Z_ZVEC        Z_Which = 25
	Z_ZVECVEC     Z_Which = 26
	Z_ZDATE       Z_Which = 27
	Z_ZDATA       Z_Which = 28
	Z_AIRCRAFTVEC Z_Which = 29
	Z_AIRCRAFT    Z_Which = 30
	Z_REGRESSION  Z_Which = 31
	Z_PLANEBASE   Z_Which = 32
	Z_AIRPORT     Z_Which = 33
	Z_B737        Z_Which = 34
	Z_A320        Z_Which = 35
	Z_F16         Z_Which = 36
	Z_ZDATEVEC    Z_Which = 37
	Z_ZDATAVEC    Z_Which = 38
	Z_BOOLVEC     Z_Which = 39
)

func NewZ(s *C.Segment) Z      { return Z(s.NewStruct(16, 1)) }
func NewRootZ(s *C.Segment) Z  { return Z(s.NewRootStruct(16, 1)) }
func AutoNewZ(s *C.Segment) Z  { return Z(s.NewStructAR(16, 1)) }
func ReadRootZ(s *C.Segment) Z { return Z(s.Root(0).ToStruct()) }
func (s Z) Which() Z_Which     { return Z_Which(C.Struct(s).Get16(0)) }
func (s Z) SetVoid()           { C.Struct(s).Set16(0, 0) }
func (s Z) Zz() Z              { return Z(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetZz(v Z)          { C.Struct(s).Set16(0, 1); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) F64() float64       { return math.Float64frombits(C.Struct(s).Get64(8)) }
func (s Z) SetF64(v float64)   { C.Struct(s).Set16(0, 2); C.Struct(s).Set64(8, math.Float64bits(v)) }
func (s Z) F32() float32       { return math.Float32frombits(C.Struct(s).Get32(8)) }
func (s Z) SetF32(v float32)   { C.Struct(s).Set16(0, 3); C.Struct(s).Set32(8, math.Float32bits(v)) }
func (s Z) I64() int64         { return int64(C.Struct(s).Get64(8)) }
func (s Z) SetI64(v int64)     { C.Struct(s).Set16(0, 4); C.Struct(s).Set64(8, uint64(v)) }
func (s Z) I32() int32         { return int32(C.Struct(s).Get32(8)) }
func (s Z) SetI32(v int32)     { C.Struct(s).Set16(0, 5); C.Struct(s).Set32(8, uint32(v)) }
func (s Z) I16() int16         { return int16(C.Struct(s).Get16(8)) }
func (s Z) SetI16(v int16)     { C.Struct(s).Set16(0, 6); C.Struct(s).Set16(8, uint16(v)) }
func (s Z) I8() int8           { return int8(C.Struct(s).Get8(8)) }
func (s Z) SetI8(v int8)       { C.Struct(s).Set16(0, 7); C.Struct(s).Set8(8, uint8(v)) }
func (s Z) U64() uint64        { return C.Struct(s).Get64(8) }
func (s Z) SetU64(v uint64)    { C.Struct(s).Set16(0, 8); C.Struct(s).Set64(8, v) }
func (s Z) U32() uint32        { return C.Struct(s).Get32(8) }
func (s Z) SetU32(v uint32)    { C.Struct(s).Set16(0, 9); C.Struct(s).Set32(8, v) }
func (s Z) U16() uint16        { return C.Struct(s).Get16(8) }
func (s Z) SetU16(v uint16)    { C.Struct(s).Set16(0, 10); C.Struct(s).Set16(8, v) }
func (s Z) U8() uint8          { return C.Struct(s).Get8(8) }
func (s Z) SetU8(v uint8)      { C.Struct(s).Set16(0, 11); C.Struct(s).Set8(8, v) }
func (s Z) Bool() bool         { return C.Struct(s).Get1(64) }
func (s Z) SetBool(v bool)     { C.Struct(s).Set16(0, 12); C.Struct(s).Set1(64, v) }
func (s Z) Text() string       { return C.Struct(s).GetObject(0).ToText() }
func (s Z) TextBytes() []byte  { return C.Struct(s).GetObject(0).ToDataTrimLastByte() }
func (s Z) SetText(v string) {
	C.Struct(s).Set16(0, 13)
	C.Struct(s).SetObject(0, s.Segment.NewText(v))
}
func (s Z) Blob() []byte { return C.Struct(s).GetObject(0).ToData() }
func (s Z) SetBlob(v []byte) {
	C.Struct(s).Set16(0, 14)
	C.Struct(s).SetObject(0, s.Segment.NewData(v))
}
func (s Z) F64vec() C.Float64List { return C.Float64List(C.Struct(s).GetObject(0)) }
func (s Z) SetF64vec(v C.Float64List) {
	C.Struct(s).Set16(0, 15)
	C.Struct(s).SetObject(0, C.Object(v))
}
func (s Z) F32vec() C.Float32List { return C.Float32List(C.Struct(s).GetObject(0)) }
func (s Z) SetF32vec(v C.Float32List) {
	C.Struct(s).Set16(0, 16)
	C.Struct(s).SetObject(0, C.Object(v))
}
func (s Z) I64vec() C.Int64List      { return C.Int64List(C.Struct(s).GetObject(0)) }
func (s Z) SetI64vec(v C.Int64List)  { C.Struct(s).Set16(0, 17); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) I32vec() C.Int32List      { return C.Int32List(C.Struct(s).GetObject(0)) }
func (s Z) SetI32vec(v C.Int32List)  { C.Struct(s).Set16(0, 18); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) I16vec() C.Int16List      { return C.Int16List(C.Struct(s).GetObject(0)) }
func (s Z) SetI16vec(v C.Int16List)  { C.Struct(s).Set16(0, 19); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) I8vec() C.Int8List        { return C.Int8List(C.Struct(s).GetObject(0)) }
func (s Z) SetI8vec(v C.Int8List)    { C.Struct(s).Set16(0, 20); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) U64vec() C.UInt64List     { return C.UInt64List(C.Struct(s).GetObject(0)) }
func (s Z) SetU64vec(v C.UInt64List) { C.Struct(s).Set16(0, 21); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) U32vec() C.UInt32List     { return C.UInt32List(C.Struct(s).GetObject(0)) }
func (s Z) SetU32vec(v C.UInt32List) { C.Struct(s).Set16(0, 22); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) U16vec() C.UInt16List     { return C.UInt16List(C.Struct(s).GetObject(0)) }
func (s Z) SetU16vec(v C.UInt16List) { C.Struct(s).Set16(0, 23); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) U8vec() C.UInt8List       { return C.UInt8List(C.Struct(s).GetObject(0)) }
func (s Z) SetU8vec(v C.UInt8List)   { C.Struct(s).Set16(0, 24); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Zvec() Z_List             { return Z_List(C.Struct(s).GetObject(0)) }
func (s Z) SetZvec(v Z_List)         { C.Struct(s).Set16(0, 25); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Zvecvec() C.PointerList   { return C.PointerList(C.Struct(s).GetObject(0)) }
func (s Z) SetZvecvec(v C.PointerList) {
	C.Struct(s).Set16(0, 26)
	C.Struct(s).SetObject(0, C.Object(v))
}
func (s Z) Zdate() Zdate               { return Zdate(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetZdate(v Zdate)           { C.Struct(s).Set16(0, 27); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Zdata() Zdata               { return Zdata(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetZdata(v Zdata)           { C.Struct(s).Set16(0, 28); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Aircraftvec() Aircraft_List { return Aircraft_List(C.Struct(s).GetObject(0)) }
func (s Z) SetAircraftvec(v Aircraft_List) {
	C.Struct(s).Set16(0, 29)
	C.Struct(s).SetObject(0, C.Object(v))
}
func (s Z) Aircraft() Aircraft     { return Aircraft(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetAircraft(v Aircraft) { C.Struct(s).Set16(0, 30); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Regression() Regression { return Regression(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetRegression(v Regression) {
	C.Struct(s).Set16(0, 31)
	C.Struct(s).SetObject(0, C.Object(v))
}
func (s Z) Planebase() PlaneBase     { return PlaneBase(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetPlanebase(v PlaneBase) { C.Struct(s).Set16(0, 32); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Airport() Airport         { return Airport(C.Struct(s).Get16(8)) }
func (s Z) SetAirport(v Airport)     { C.Struct(s).Set16(0, 33); C.Struct(s).Set16(8, uint16(v)) }
func (s Z) B737() B737               { return B737(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetB737(v B737)           { C.Struct(s).Set16(0, 34); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) A320() A320               { return A320(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetA320(v A320)           { C.Struct(s).Set16(0, 35); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) F16() F16                 { return F16(C.Struct(s).GetObject(0).ToStruct()) }
func (s Z) SetF16(v F16)             { C.Struct(s).Set16(0, 36); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Zdatevec() Zdate_List     { return Zdate_List(C.Struct(s).GetObject(0)) }
func (s Z) SetZdatevec(v Zdate_List) { C.Struct(s).Set16(0, 37); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Zdatavec() Zdata_List     { return Zdata_List(C.Struct(s).GetObject(0)) }
func (s Z) SetZdatavec(v Zdata_List) { C.Struct(s).Set16(0, 38); C.Struct(s).SetObject(0, C.Object(v)) }
func (s Z) Boolvec() C.BitList       { return C.BitList(C.Struct(s).GetObject(0)) }
func (s Z) SetBoolvec(v C.BitList)   { C.Struct(s).Set16(0, 39); C.Struct(s).SetObject(0, C.Object(v)) }

type Z_List C.PointerList

func NewZList(s *C.Segment, sz int) Z_List { return Z_List(s.NewCompositeList(16, 1, sz)) }
func (s Z_List) Len() int                  { return C.PointerList(s).Len() }
func (s Z_List) At(i int) Z                { return Z(C.PointerList(s).At(i).ToStruct()) }
func (s Z_List) ToArray() []Z {
	n := s.Len()
	a := make([]Z, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Z_List) Set(i int, item Z) { C.PointerList(s).Set(i, C.Object(item)) }

type Z_Struct struct {
	Which       Z_Which
	Zz          *Z_Struct
	F64         float64
	F32         float32
	I64         int64
	I32         int32
	I16         int16
	I8          int8
	U64         uint64
	U32         uint32
	U16         uint16
	U8          uint8
	Bool        bool
	Text        string
	Blob        []byte
	F64vec      []float64
	F32vec      []float32
	I64vec      []int64
	I32vec      []int32
	I16vec      []int16
	I8vec       []int8
	U64vec      []uint64
	U32vec      []uint32
	U16vec      []uint16
	U8vec       []uint8
	Zvec        []*Z_Struct
	Zvecvec     [][]*Z_Struct
	Zdate       *Zdate_Struct
	Zdata       *Zdata_Struct
	Aircraftvec []*Aircraft_Struct
	Aircraft    *Aircraft_Struct
	Regression  *Regression_Struct
	Planebase   *PlaneBase_Struct
	Airport     Airport
	B737        *B737_Struct
	A320        *A320_Struct
	F16         *F16_Struct
	Zdatevec    []*Zdate_Struct
	Zdatavec    []*Zdata_Struct
	Boolvec     []bool
}

func (s Z) Struct() *Z_Struct {
	t := &Z_Struct{}
	t.Which = s.Which()
	if t.Which == Z_ZZ {
		{
			t.Zz = s.Zz().Struct()
		}
	}
	if t.Which == Z_F64 {
		t.F64 = s.F64()
	}
	if t.Which == Z_F32 {
		t.F32 = s.F32()
	}
	if t.Which == Z_I64 {
		t.I64 = s.I64()
	}
	if t.Which == Z_I32 {
		t.I32 = s.I32()
	}
	if t.Which == Z_I16 {
		t.I16 = s.I16()
	}
	if t.Which == Z_I8 {
		t.I8 = s.I8()
	}
	if t.Which == Z_U64 {
		t.U64 = s.U64()
	}
	if t.Which == Z_U32 {
		t.U32 = s.U32()
	}
	if t.Which == Z_U16 {
		t.U16 = s.U16()
	}
	if t.Which == Z_U8 {
		t.U8 = s.U8()
	}
	if t.Which == Z_BOOL {
		t.Bool = s.Bool()
	}
	if t.Which == Z_TEXT {
		t.Text = s.Text()
	}
	if t.Which == Z_BLOB {
		t.Blob = s.Blob()
	}
	if t.Which == Z_F64VEC {
		for i := 0; i < s.F64vec().Len(); i++ {
			t.F64vec = append(t.F64vec, s.F64vec().At(i))
		}
	}
	if t.Which == Z_F32VEC {
		for i := 0; i < s.F32vec().Len(); i++ {
			t.F32vec = append(t.F32vec, s.F32vec().At(i))
		}
	}
	if t.Which == Z_I64VEC {
		for i := 0; i < s.I64vec().Len(); i++ {
			t.I64vec = append(t.I64vec, s.I64vec().At(i))
		}
	}
	if t.Which == Z_I32VEC {
		for i := 0; i < s.I32vec().Len(); i++ {
			t.I32vec = append(t.I32vec, s.I32vec().At(i))
		}
	}
	if t.Which == Z_I16VEC {
		for i := 0; i < s.I16vec().Len(); i++ {
			t.I16vec = append(t.I16vec, s.I16vec().At(i))
		}
	}
	if t.Which == Z_I8VEC {
		for i := 0; i < s.I8vec().Len(); i++ {
			t.I8vec = append(t.I8vec, s.I8vec().At(i))
		}
	}
	if t.Which == Z_U64VEC {
		for i := 0; i < s.U64vec().Len(); i++ {
			t.U64vec = append(t.U64vec, s.U64vec().At(i))
		}
	}
	if t.Which == Z_U32VEC {
		for i := 0; i < s.U32vec().Len(); i++ {
			t.U32vec = append(t.U32vec, s.U32vec().At(i))
		}
	}
	if t.Which == Z_U16VEC {
		for i := 0; i < s.U16vec().Len(); i++ {
			t.U16vec = append(t.U16vec, s.U16vec().At(i))
		}
	}
	if t.Which == Z_U8VEC {
		for i := 0; i < s.U8vec().Len(); i++ {
			t.U8vec = append(t.U8vec, s.U8vec().At(i))
		}
	}
	if t.Which == Z_ZVEC {
		for i := 0; i < s.Zvec().Len(); i++ {
			elem := s.Zvec().At(i).Struct()
			t.Zvec = append(t.Zvec, elem)
		}
	}
	if t.Which == Z_ZVECVEC {
		for i := 0; i < s.Zvecvec().Len(); i++ {
			t.Zvecvec = nil
			panic("List of List not supported now")
		}
	}
	if t.Which == Z_ZDATE {
		{
			t.Zdate = s.Zdate().Struct()
		}
	}
	if t.Which == Z_ZDATA {
		{
			t.Zdata = s.Zdata().Struct()
		}
	}
	if t.Which == Z_AIRCRAFTVEC {
		for i := 0; i < s.Aircraftvec().Len(); i++ {
			elem := s.Aircraftvec().At(i).Struct()
			t.Aircraftvec = append(t.Aircraftvec, elem)
		}
	}
	if t.Which == Z_AIRCRAFT {
		{
			t.Aircraft = s.Aircraft().Struct()
		}
	}
	if t.Which == Z_REGRESSION {
		{
			t.Regression = s.Regression().Struct()
		}
	}
	if t.Which == Z_PLANEBASE {
		{
			t.Planebase = s.Planebase().Struct()
		}
	}
	if t.Which == Z_AIRPORT {
		t.Airport = s.Airport()
	}
	if t.Which == Z_B737 {
		{
			t.B737 = s.B737().Struct()
		}
	}
	if t.Which == Z_A320 {
		{
			t.A320 = s.A320().Struct()
		}
	}
	if t.Which == Z_F16 {
		{
			t.F16 = s.F16().Struct()
		}
	}
	if t.Which == Z_ZDATEVEC {
		for i := 0; i < s.Zdatevec().Len(); i++ {
			elem := s.Zdatevec().At(i).Struct()
			t.Zdatevec = append(t.Zdatevec, elem)
		}
	}
	if t.Which == Z_ZDATAVEC {
		for i := 0; i < s.Zdatavec().Len(); i++ {
			elem := s.Zdatavec().At(i).Struct()
			t.Zdatavec = append(t.Zdatavec, elem)
		}
	}
	if t.Which == Z_BOOLVEC {
		for i := 0; i < s.Boolvec().Len(); i++ {
			t.Boolvec = append(t.Boolvec, s.Boolvec().At(i))
		}
	}
	return t
}
func (s Z) LoadStruct(t *Z_Struct) {
	if t == nil {
		return
	}
	if t.Which == Z_VOID {
		s.SetVoid()
	}
	if t.Which == Z_ZZ {
		{
			p := NewZ(s.Segment)
			p.LoadStruct(t.Zz)
			s.SetZz(p)
		}
	}
	if t.Which == Z_F64 {
		s.SetF64(t.F64)
	}
	if t.Which == Z_F32 {
		s.SetF32(t.F32)
	}
	if t.Which == Z_I64 {
		s.SetI64(t.I64)
	}
	if t.Which == Z_I32 {
		s.SetI32(t.I32)
	}
	if t.Which == Z_I16 {
		s.SetI16(t.I16)
	}
	if t.Which == Z_I8 {
		s.SetI8(t.I8)
	}
	if t.Which == Z_U64 {
		s.SetU64(t.U64)
	}
	if t.Which == Z_U32 {
		s.SetU32(t.U32)
	}
	if t.Which == Z_U16 {
		s.SetU16(t.U16)
	}
	if t.Which == Z_U8 {
		s.SetU8(t.U8)
	}
	if t.Which == Z_BOOL {
		s.SetBool(t.Bool)
	}
	if t.Which == Z_TEXT {
		s.SetText(t.Text)
	}
	if t.Which == Z_BLOB {
		s.SetBlob(t.Blob)
	}
	if t.Which == Z_F64VEC {
		s.SetF64vec(s.Segment.NewFloat64List(len(t.F64vec)))
		for i := 0; i < len(t.F64vec); i++ {
			s.F64vec().Set(i, t.F64vec[i])
		}
	}
	if t.Which == Z_F32VEC {
		s.SetF32vec(s.Segment.NewFloat32List(len(t.F32vec)))
		for i := 0; i < len(t.F32vec); i++ {
			s.F32vec().Set(i, t.F32vec[i])
		}
	}
	if t.Which == Z_I64VEC {
		s.SetI64vec(s.Segment.NewInt64List(len(t.I64vec)))
		for i := 0; i < len(t.I64vec); i++ {
			s.I64vec().Set(i, t.I64vec[i])
		}
	}
	if t.Which == Z_I32VEC {
		s.SetI32vec(s.Segment.NewInt32List(len(t.I32vec)))
		for i := 0; i < len(t.I32vec); i++ {
			s.I32vec().Set(i, t.I32vec[i])
		}
	}
	if t.Which == Z_I16VEC {
		s.SetI16vec(s.Segment.NewInt16List(len(t.I16vec)))
		for i := 0; i < len(t.I16vec); i++ {
			s.I16vec().Set(i, t.I16vec[i])
		}
	}
	if t.Which == Z_I8VEC {
		s.SetI8vec(s.Segment.NewInt8List(len(t.I8vec)))
		for i := 0; i < len(t.I8vec); i++ {
			s.I8vec().Set(i, t.I8vec[i])
		}
	}
	if t.Which == Z_U64VEC {
		s.SetU64vec(s.Segment.NewUInt64List(len(t.U64vec)))
		for i := 0; i < len(t.U64vec); i++ {
			s.U64vec().Set(i, t.U64vec[i])
		}
	}
	if t.Which == Z_U32VEC {
		s.SetU32vec(s.Segment.NewUInt32List(len(t.U32vec)))
		for i := 0; i < len(t.U32vec); i++ {
			s.U32vec().Set(i, t.U32vec[i])
		}
	}
	if t.Which == Z_U16VEC {
		s.SetU16vec(s.Segment.NewUInt16List(len(t.U16vec)))
		for i := 0; i < len(t.U16vec); i++ {
			s.U16vec().Set(i, t.U16vec[i])
		}
	}
	if t.Which == Z_U8VEC {
		s.SetU8vec(s.Segment.NewUInt8List(len(t.U8vec)))
		for i := 0; i < len(t.U8vec); i++ {
			s.U8vec().Set(i, t.U8vec[i])
		}
	}
	if t.Which == Z_ZVEC {
		s.SetZvec(NewZList(s.Segment, len(t.Zvec)))
		for i := 0; i < len(t.Zvec); i++ {
			s.Zvec().Set(i, t.Zvec[i].Capnp(s.Segment))
		}
	}
	if t.Which == Z_ZVECVEC {
		s.SetZvecvec(s.Segment.NewPointerList(len(t.Zvecvec)))
		for i := 0; i < len(t.Zvecvec); i++ {
			panic("List of List not supported now")
		}
	}
	if t.Which == Z_ZDATE {
		{
			p := NewZdate(s.Segment)
			p.LoadStruct(t.Zdate)
			s.SetZdate(p)
		}
	}
	if t.Which == Z_ZDATA {
		{
			p := NewZdata(s.Segment)
			p.LoadStruct(t.Zdata)
			s.SetZdata(p)
		}
	}
	if t.Which == Z_AIRCRAFTVEC {
		s.SetAircraftvec(NewAircraftList(s.Segment, len(t.Aircraftvec)))
		for i := 0; i < len(t.Aircraftvec); i++ {
			s.Aircraftvec().Set(i, t.Aircraftvec[i].Capnp(s.Segment))
		}
	}
	if t.Which == Z_AIRCRAFT {
		{
			p := NewAircraft(s.Segment)
			p.LoadStruct(t.Aircraft)
			s.SetAircraft(p)
		}
	}
	if t.Which == Z_REGRESSION {
		{
			p := NewRegression(s.Segment)
			p.LoadStruct(t.Regression)
			s.SetRegression(p)
		}
	}
	if t.Which == Z_PLANEBASE {
		{
			p := NewPlaneBase(s.Segment)
			p.LoadStruct(t.Planebase)
			s.SetPlanebase(p)
		}
	}
	if t.Which == Z_AIRPORT {
		s.SetAirport(t.Airport)
	}
	if t.Which == Z_B737 {
		{
			p := NewB737(s.Segment)
			p.LoadStruct(t.B737)
			s.SetB737(p)
		}
	}
	if t.Which == Z_A320 {
		{
			p := NewA320(s.Segment)
			p.LoadStruct(t.A320)
			s.SetA320(p)
		}
	}
	if t.Which == Z_F16 {
		{
			p := NewF16(s.Segment)
			p.LoadStruct(t.F16)
			s.SetF16(p)
		}
	}
	if t.Which == Z_ZDATEVEC {
		s.SetZdatevec(NewZdateList(s.Segment, len(t.Zdatevec)))
		for i := 0; i < len(t.Zdatevec); i++ {
			s.Zdatevec().Set(i, t.Zdatevec[i].Capnp(s.Segment))
		}
	}
	if t.Which == Z_ZDATAVEC {
		s.SetZdatavec(NewZdataList(s.Segment, len(t.Zdatavec)))
		for i := 0; i < len(t.Zdatavec); i++ {
			s.Zdatavec().Set(i, t.Zdatavec[i].Capnp(s.Segment))
		}
	}
	if t.Which == Z_BOOLVEC {
		s.SetBoolvec(s.Segment.NewBitList(len(t.Boolvec)))
		for i := 0; i < len(t.Boolvec); i++ {
			s.Boolvec().Set(i, t.Boolvec[i])
		}
	}
}
func (s *Z_Struct) Copy() *Z_Struct {
	t := &Z_Struct{}
	t.Which = s.Which
	if s.Zz != nil {
		t.Zz = s.Zz.Copy()
	}
	t.F64 = s.F64
	t.F32 = s.F32
	t.I64 = s.I64
	t.I32 = s.I32
	t.I16 = s.I16
	t.I8 = s.I8
	t.U64 = s.U64
	t.U32 = s.U32
	t.U16 = s.U16
	t.U8 = s.U8
	t.Bool = s.Bool
	t.Text = s.Text
	t.Blob = s.Blob
	for _, e := range s.F64vec {
		t.F64vec = append(t.F64vec, e)
	}
	for _, e := range s.F32vec {
		t.F32vec = append(t.F32vec, e)
	}
	for _, e := range s.I64vec {
		t.I64vec = append(t.I64vec, e)
	}
	for _, e := range s.I32vec {
		t.I32vec = append(t.I32vec, e)
	}
	for _, e := range s.I16vec {
		t.I16vec = append(t.I16vec, e)
	}
	for _, e := range s.I8vec {
		t.I8vec = append(t.I8vec, e)
	}
	for _, e := range s.U64vec {
		t.U64vec = append(t.U64vec, e)
	}
	for _, e := range s.U32vec {
		t.U32vec = append(t.U32vec, e)
	}
	for _, e := range s.U16vec {
		t.U16vec = append(t.U16vec, e)
	}
	for _, e := range s.U8vec {
		t.U8vec = append(t.U8vec, e)
	}
	for _, e := range s.Zvec {
		if e != nil {
			t.Zvec = append(t.Zvec, e.Copy())
		} else {
			t.Zvec = append(t.Zvec, nil)
		}
	}
	for _, e := range s.Zvecvec {
		t.Zvecvec = append(t.Zvecvec, e)
	}
	if s.Zdate != nil {
		t.Zdate = s.Zdate.Copy()
	}
	if s.Zdata != nil {
		t.Zdata = s.Zdata.Copy()
	}
	for _, e := range s.Aircraftvec {
		if e != nil {
			t.Aircraftvec = append(t.Aircraftvec, e.Copy())
		} else {
			t.Aircraftvec = append(t.Aircraftvec, nil)
		}
	}
	if s.Aircraft != nil {
		t.Aircraft = s.Aircraft.Copy()
	}
	if s.Regression != nil {
		t.Regression = s.Regression.Copy()
	}
	if s.Planebase != nil {
		t.Planebase = s.Planebase.Copy()
	}
	t.Airport = s.Airport
	if s.B737 != nil {
		t.B737 = s.B737.Copy()
	}
	if s.A320 != nil {
		t.A320 = s.A320.Copy()
	}
	if s.F16 != nil {
		t.F16 = s.F16.Copy()
	}
	for _, e := range s.Zdatevec {
		if e != nil {
			t.Zdatevec = append(t.Zdatevec, e.Copy())
		} else {
			t.Zdatevec = append(t.Zdatevec, nil)
		}
	}
	for _, e := range s.Zdatavec {
		if e != nil {
			t.Zdatavec = append(t.Zdatavec, e.Copy())
		} else {
			t.Zdatavec = append(t.Zdatavec, nil)
		}
	}
	for _, e := range s.Boolvec {
		t.Boolvec = append(t.Boolvec, e)
	}
	return t
}
func (s *Z_Struct) Capnp(seg *C.Segment) Z {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewZ(seg)
	t.LoadStruct(s)
	return t
}
func (s *Z_Struct) RootCapnp(seg *C.Segment) Z {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootZ(seg)
	t.LoadStruct(s)
	return t
}
func (s Z) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if s.Which() == Z_VOID {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"void\":")
			if err != nil {
				return err
			}
			_ = s
			_, err = b.WriteString("null")
			if err != nil {
				return err
			}
		}
		if s.Which() == Z_ZZ {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"zz\":")
			if err != nil {
				return err
			}
			{
				s := s.Zz()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_F64 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"f64\":")
			if err != nil {
				return err
			}
			{
				s := s.F64()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_F32 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"f32\":")
			if err != nil {
				return err
			}
			{
				s := s.F32()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I64 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i64\":")
			if err != nil {
				return err
			}
			{
				s := s.I64()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I32 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i32\":")
			if err != nil {
				return err
			}
			{
				s := s.I32()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I16 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i16\":")
			if err != nil {
				return err
			}
			{
				s := s.I16()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I8 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i8\":")
			if err != nil {
				return err
			}
			{
				s := s.I8()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U64 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u64\":")
			if err != nil {
				return err
			}
			{
				s := s.U64()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U32 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u32\":")
			if err != nil {
				return err
			}
			{
				s := s.U32()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U16 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u16\":")
			if err != nil {
				return err
			}
			{
				s := s.U16()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U8 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u8\":")
			if err != nil {
				return err
			}
			{
				s := s.U8()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_BOOL {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"bool\":")
			if err != nil {
				return err
			}
			{
				s := s.Bool()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_TEXT {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"text\":")
			if err != nil {
				return err
			}
			{
				s := s.Text()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_BLOB {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"blob\":")
			if err != nil {
				return err
			}
			{
				s := s.Blob()
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_F64VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"f64vec\":")
			if err != nil {
				return err
			}
			{
				s := s.F64vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_F32VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"f32vec\":")
			if err != nil {
				return err
			}
			{
				s := s.F32vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I64VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i64vec\":")
			if err != nil {
				return err
			}
			{
				s := s.I64vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I32VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i32vec\":")
			if err != nil {
				return err
			}
			{
				s := s.I32vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I16VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i16vec\":")
			if err != nil {
				return err
			}
			{
				s := s.I16vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_I8VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"i8vec\":")
			if err != nil {
				return err
			}
			{
				s := s.I8vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U64VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u64vec\":")
			if err != nil {
				return err
			}
			{
				s := s.U64vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U32VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u32vec\":")
			if err != nil {
				return err
			}
			{
				s := s.U32vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U16VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u16vec\":")
			if err != nil {
				return err
			}
			{
				s := s.U16vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_U8VEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"u8vec\":")
			if err != nil {
				return err
			}
			{
				s := s.U8vec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_ZVEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"zvec\":")
			if err != nil {
				return err
			}
			{
				s := s.Zvec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						err = s.WriteJSON(b)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_ZVECVEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"zvecvec\":")
			if err != nil {
				return err
			}
			{
				s := s.Zvecvec()
				_ = s
				_, err = b.WriteString("\"untyped list\"")
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_ZDATE {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"zdate\":")
			if err != nil {
				return err
			}
			{
				s := s.Zdate()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_ZDATA {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"zdata\":")
			if err != nil {
				return err
			}
			{
				s := s.Zdata()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_AIRCRAFTVEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"aircraftvec\":")
			if err != nil {
				return err
			}
			{
				s := s.Aircraftvec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						err = s.WriteJSON(b)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_AIRCRAFT {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"aircraft\":")
			if err != nil {
				return err
			}
			{
				s := s.Aircraft()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_REGRESSION {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"regression\":")
			if err != nil {
				return err
			}
			{
				s := s.Regression()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_PLANEBASE {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"planebase\":")
			if err != nil {
				return err
			}
			{
				s := s.Planebase()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_AIRPORT {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"airport\":")
			if err != nil {
				return err
			}
			{
				s := s.Airport()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_B737 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"b737\":")
			if err != nil {
				return err
			}
			{
				s := s.B737()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_A320 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"a320\":")
			if err != nil {
				return err
			}
			{
				s := s.A320()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_F16 {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"f16\":")
			if err != nil {
				return err
			}
			{
				s := s.F16()
				err = s.WriteJSON(b)
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_ZDATEVEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"zdatevec\":")
			if err != nil {
				return err
			}
			{
				s := s.Zdatevec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						err = s.WriteJSON(b)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_ZDATAVEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"zdatavec\":")
			if err != nil {
				return err
			}
			{
				s := s.Zdatavec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						err = s.WriteJSON(b)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		if s.Which() == Z_BOOLVEC {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"boolvec\":")
			if err != nil {
				return err
			}
			{
				s := s.Boolvec()
				{
					err = b.WriteByte('[')
					if err != nil {
						return err
					}
					for i, s := range s.ToArray() {
						if i != 0 {
							_, err = b.WriteString(", ")
						}
						if err != nil {
							return err
						}
						buf, err = json.Marshal(s)
						if err != nil {
							return err
						}
						_, err = b.Write(buf)
						if err != nil {
							return err
						}
					}
					err = b.WriteByte(']')
				}
				if err != nil {
					return err
				}
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Z) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Z) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	if s.Which() == Z_VOID {
		_, err = b.WriteString("void = ")
		if err != nil {
			return err
		}
		_ = s
		_, err = b.WriteString("null")
		if err != nil {
			return err
		}
	}
	if s.Which() == Z_ZZ {
		_, err = b.WriteString("zz = ")
		if err != nil {
			return err
		}
		{
			s := s.Zz()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_F64 {
		_, err = b.WriteString("f64 = ")
		if err != nil {
			return err
		}
		{
			s := s.F64()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_F32 {
		_, err = b.WriteString("f32 = ")
		if err != nil {
			return err
		}
		{
			s := s.F32()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I64 {
		_, err = b.WriteString("i64 = ")
		if err != nil {
			return err
		}
		{
			s := s.I64()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I32 {
		_, err = b.WriteString("i32 = ")
		if err != nil {
			return err
		}
		{
			s := s.I32()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I16 {
		_, err = b.WriteString("i16 = ")
		if err != nil {
			return err
		}
		{
			s := s.I16()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I8 {
		_, err = b.WriteString("i8 = ")
		if err != nil {
			return err
		}
		{
			s := s.I8()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U64 {
		_, err = b.WriteString("u64 = ")
		if err != nil {
			return err
		}
		{
			s := s.U64()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U32 {
		_, err = b.WriteString("u32 = ")
		if err != nil {
			return err
		}
		{
			s := s.U32()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U16 {
		_, err = b.WriteString("u16 = ")
		if err != nil {
			return err
		}
		{
			s := s.U16()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U8 {
		_, err = b.WriteString("u8 = ")
		if err != nil {
			return err
		}
		{
			s := s.U8()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_BOOL {
		_, err = b.WriteString("bool = ")
		if err != nil {
			return err
		}
		{
			s := s.Bool()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_TEXT {
		_, err = b.WriteString("text = ")
		if err != nil {
			return err
		}
		{
			s := s.Text()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_BLOB {
		_, err = b.WriteString("blob = ")
		if err != nil {
			return err
		}
		{
			s := s.Blob()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_F64VEC {
		_, err = b.WriteString("f64vec = ")
		if err != nil {
			return err
		}
		{
			s := s.F64vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_F32VEC {
		_, err = b.WriteString("f32vec = ")
		if err != nil {
			return err
		}
		{
			s := s.F32vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I64VEC {
		_, err = b.WriteString("i64vec = ")
		if err != nil {
			return err
		}
		{
			s := s.I64vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I32VEC {
		_, err = b.WriteString("i32vec = ")
		if err != nil {
			return err
		}
		{
			s := s.I32vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I16VEC {
		_, err = b.WriteString("i16vec = ")
		if err != nil {
			return err
		}
		{
			s := s.I16vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_I8VEC {
		_, err = b.WriteString("i8vec = ")
		if err != nil {
			return err
		}
		{
			s := s.I8vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U64VEC {
		_, err = b.WriteString("u64vec = ")
		if err != nil {
			return err
		}
		{
			s := s.U64vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U32VEC {
		_, err = b.WriteString("u32vec = ")
		if err != nil {
			return err
		}
		{
			s := s.U32vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U16VEC {
		_, err = b.WriteString("u16vec = ")
		if err != nil {
			return err
		}
		{
			s := s.U16vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_U8VEC {
		_, err = b.WriteString("u8vec = ")
		if err != nil {
			return err
		}
		{
			s := s.U8vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_ZVEC {
		_, err = b.WriteString("zvec = ")
		if err != nil {
			return err
		}
		{
			s := s.Zvec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteCapLit(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_ZVECVEC {
		_, err = b.WriteString("zvecvec = ")
		if err != nil {
			return err
		}
		{
			s := s.Zvecvec()
			_ = s
			_, err = b.WriteString("\"untyped list\"")
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_ZDATE {
		_, err = b.WriteString("zdate = ")
		if err != nil {
			return err
		}
		{
			s := s.Zdate()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_ZDATA {
		_, err = b.WriteString("zdata = ")
		if err != nil {
			return err
		}
		{
			s := s.Zdata()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_AIRCRAFTVEC {
		_, err = b.WriteString("aircraftvec = ")
		if err != nil {
			return err
		}
		{
			s := s.Aircraftvec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteCapLit(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_AIRCRAFT {
		_, err = b.WriteString("aircraft = ")
		if err != nil {
			return err
		}
		{
			s := s.Aircraft()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_REGRESSION {
		_, err = b.WriteString("regression = ")
		if err != nil {
			return err
		}
		{
			s := s.Regression()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_PLANEBASE {
		_, err = b.WriteString("planebase = ")
		if err != nil {
			return err
		}
		{
			s := s.Planebase()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_AIRPORT {
		_, err = b.WriteString("airport = ")
		if err != nil {
			return err
		}
		{
			s := s.Airport()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_B737 {
		_, err = b.WriteString("b737 = ")
		if err != nil {
			return err
		}
		{
			s := s.B737()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_A320 {
		_, err = b.WriteString("a320 = ")
		if err != nil {
			return err
		}
		{
			s := s.A320()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_F16 {
		_, err = b.WriteString("f16 = ")
		if err != nil {
			return err
		}
		{
			s := s.F16()
			err = s.WriteCapLit(b)
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_ZDATEVEC {
		_, err = b.WriteString("zdatevec = ")
		if err != nil {
			return err
		}
		{
			s := s.Zdatevec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteCapLit(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_ZDATAVEC {
		_, err = b.WriteString("zdatavec = ")
		if err != nil {
			return err
		}
		{
			s := s.Zdatavec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteCapLit(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	if s.Which() == Z_BOOLVEC {
		_, err = b.WriteString("boolvec = ")
		if err != nil {
			return err
		}
		{
			s := s.Boolvec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Z) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewZFromCapLit(s *C.Segment, b []byte) (p Z, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewZ(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootZFromCapLit(s *C.Segment, b []byte) (p Z, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootZ(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Z) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["void"]; ok {
		_ = fn
		s.SetVoid()
	}
	if fn, ok := sv["zz"]; ok {
		_ = fn
		t := NewZ(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetZz(t)
	}
	if fn, ok := sv["f64"]; ok {
		_ = fn
		var t float64
		if temp, ok := fn.Val.(float64); ok {
			t = float64(temp)
		} else {
			return fmt.Errorf("expected 'float64' but didn't matched")
		}
		_ = t
		s.SetF64(t)
	}
	if fn, ok := sv["f32"]; ok {
		_ = fn
		var t float32
		if temp, ok := fn.Val.(float64); ok {
			t = float32(temp)
		} else {
			return fmt.Errorf("expected 'float32' but didn't matched")
		}
		_ = t
		s.SetF32(t)
	}
	if fn, ok := sv["i64"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetI64(t)
	}
	if fn, ok := sv["i32"]; ok {
		_ = fn
		var t int32
		if temp, ok := fn.Val.(int64); ok {
			t = int32(temp)
		} else {
			return fmt.Errorf("expected 'int32' but didn't matched")
		}
		_ = t
		s.SetI32(t)
	}
	if fn, ok := sv["i16"]; ok {
		_ = fn
		var t int16
		if temp, ok := fn.Val.(int64); ok {
			t = int16(temp)
		} else {
			return fmt.Errorf("expected 'int16' but didn't matched")
		}
		_ = t
		s.SetI16(t)
	}
	if fn, ok := sv["i8"]; ok {
		_ = fn
		var t int8
		if temp, ok := fn.Val.(int64); ok {
			t = int8(temp)
		} else {
			return fmt.Errorf("expected 'int8' but didn't matched")
		}
		_ = t
		s.SetI8(t)
	}
	if fn, ok := sv["u64"]; ok {
		_ = fn
		var t uint64
		if temp, ok := fn.Val.(int64); ok {
			t = uint64(temp)
		} else {
			return fmt.Errorf("expected 'uint64' but didn't matched")
		}
		_ = t
		s.SetU64(t)
	}
	if fn, ok := sv["u32"]; ok {
		_ = fn
		var t uint32
		if temp, ok := fn.Val.(int64); ok {
			t = uint32(temp)
		} else {
			return fmt.Errorf("expected 'uint32' but didn't matched")
		}
		_ = t
		s.SetU32(t)
	}
	if fn, ok := sv["u16"]; ok {
		_ = fn
		var t uint16
		if temp, ok := fn.Val.(int64); ok {
			t = uint16(temp)
		} else {
			return fmt.Errorf("expected 'uint16' but didn't matched")
		}
		_ = t
		s.SetU16(t)
	}
	if fn, ok := sv["u8"]; ok {
		_ = fn
		var t uint8
		if temp, ok := fn.Val.(int64); ok {
			t = uint8(temp)
		} else {
			return fmt.Errorf("expected 'uint8' but didn't matched")
		}
		_ = t
		s.SetU8(t)
	}
	if fn, ok := sv["bool"]; ok {
		_ = fn
		t, ok := fn.Val.(bool)
		if !ok {
			return fmt.Errorf("expected 'bool' but didn't matched")
		}
		_ = t
		s.SetBool(t)
	}
	if fn, ok := sv["text"]; ok {
		_ = fn
		t, ok := fn.Val.(string)
		if !ok {
			return fmt.Errorf("expected 'string' but didn't matched")
		}
		_ = t
		s.SetText(t)
	}
	if fn, ok := sv["blob"]; ok {
		_ = fn
		var t []byte
		if temp, ok := fn.Val.(string); ok {
			t = []byte(temp)
		} else {
			return fmt.Errorf("expected '[]byte' but didn't matched")
		}
		_ = t
		s.SetBlob(t)
	}
	if fn, ok := sv["f64vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewFloat64List(len(lv))
		for i, en := range lv {
			_ = en
			var ev float64
			if temp, ok := en.Val.(float64); ok {
				ev = float64(temp)
			} else {
				return fmt.Errorf("expected 'float64' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetF64vec(t)
	}
	if fn, ok := sv["f32vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewFloat32List(len(lv))
		for i, en := range lv {
			_ = en
			var ev float32
			if temp, ok := en.Val.(float64); ok {
				ev = float32(temp)
			} else {
				return fmt.Errorf("expected 'float32' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetF32vec(t)
	}
	if fn, ok := sv["i64vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewInt64List(len(lv))
		for i, en := range lv {
			_ = en
			var ev int64
			if temp, ok := en.Val.(int64); ok {
				ev = int64(temp)
			} else {
				return fmt.Errorf("expected 'int64' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetI64vec(t)
	}
	if fn, ok := sv["i32vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewInt32List(len(lv))
		for i, en := range lv {
			_ = en
			var ev int32
			if temp, ok := en.Val.(int64); ok {
				ev = int32(temp)
			} else {
				return fmt.Errorf("expected 'int32' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetI32vec(t)
	}
	if fn, ok := sv["i16vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewInt16List(len(lv))
		for i, en := range lv {
			_ = en
			var ev int16
			if temp, ok := en.Val.(int64); ok {
				ev = int16(temp)
			} else {
				return fmt.Errorf("expected 'int16' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetI16vec(t)
	}
	if fn, ok := sv["i8vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewInt8List(len(lv))
		for i, en := range lv {
			_ = en
			var ev int8
			if temp, ok := en.Val.(int64); ok {
				ev = int8(temp)
			} else {
				return fmt.Errorf("expected 'int8' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetI8vec(t)
	}
	if fn, ok := sv["u64vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewUInt64List(len(lv))
		for i, en := range lv {
			_ = en
			var ev uint64
			if temp, ok := en.Val.(int64); ok {
				ev = uint64(temp)
			} else {
				return fmt.Errorf("expected 'uint64' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetU64vec(t)
	}
	if fn, ok := sv["u32vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewUInt32List(len(lv))
		for i, en := range lv {
			_ = en
			var ev uint32
			if temp, ok := en.Val.(int64); ok {
				ev = uint32(temp)
			} else {
				return fmt.Errorf("expected 'uint32' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetU32vec(t)
	}
	if fn, ok := sv["u16vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewUInt16List(len(lv))
		for i, en := range lv {
			_ = en
			var ev uint16
			if temp, ok := en.Val.(int64); ok {
				ev = uint16(temp)
			} else {
				return fmt.Errorf("expected 'uint16' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetU16vec(t)
	}
	if fn, ok := sv["u8vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewUInt8List(len(lv))
		for i, en := range lv {
			_ = en
			var ev uint8
			if temp, ok := en.Val.(int64); ok {
				ev = uint8(temp)
			} else {
				return fmt.Errorf("expected 'uint8' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetU8vec(t)
	}
	if fn, ok := sv["zvec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewZList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewZ(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetZvec(t)
	}
	if fn, ok := sv["zvecvec"]; ok {
		_ = fn
		t := C.PointerList{}
		panic("in Z, list of list' or 'list of pointer' is not supported")
		s.SetZvecvec(t)
	}
	if fn, ok := sv["zdate"]; ok {
		_ = fn
		t := NewZdate(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetZdate(t)
	}
	if fn, ok := sv["zdata"]; ok {
		_ = fn
		t := NewZdata(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetZdata(t)
	}
	if fn, ok := sv["aircraftvec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewAircraftList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewAircraft(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetAircraftvec(t)
	}
	if fn, ok := sv["aircraft"]; ok {
		_ = fn
		t := NewAircraft(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetAircraft(t)
	}
	if fn, ok := sv["regression"]; ok {
		_ = fn
		t := NewRegression(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetRegression(t)
	}
	if fn, ok := sv["planebase"]; ok {
		_ = fn
		t := NewPlaneBase(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPlanebase(t)
	}
	if fn, ok := sv["airport"]; ok {
		_ = fn
		fv, ok := fn.Val.(string)
		if !ok {
			return fmt.Errorf("expected 'string' but didn't matched")
		}
		_ = fv
		t := AirportFromString(fv)
		s.SetAirport(t)
	}
	if fn, ok := sv["b737"]; ok {
		_ = fn
		t := NewB737(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetB737(t)
	}
	if fn, ok := sv["a320"]; ok {
		_ = fn
		t := NewA320(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetA320(t)
	}
	if fn, ok := sv["f16"]; ok {
		_ = fn
		t := NewF16(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetF16(t)
	}
	if fn, ok := sv["zdatevec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewZdateList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewZdate(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetZdatevec(t)
	}
	if fn, ok := sv["zdatavec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewZdataList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewZdata(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetZdatavec(t)
	}
	if fn, ok := sv["boolvec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewBitList(len(lv))
		for i, en := range lv {
			_ = en
			ev, ok := en.Val.(bool)
			if !ok {
				return fmt.Errorf("expected 'bool' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetBoolvec(t)
	}
	return err
}
func (s Z_List) FilterIndex(f func(i int, x Z) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Z_List) Each(f func(i int, x Z) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Z_List) Find(f func(i int, x Z) bool) (Z, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Z{}, false
}
func (s Z) Seg() *C.Segment {
	return s.Segment
}
func (s Z) LitName() string {
	return "Z"
}

type Counter C.Struct

func NewCounter(s *C.Segment) Counter      { return Counter(s.NewStruct(8, 2)) }
func NewRootCounter(s *C.Segment) Counter  { return Counter(s.NewRootStruct(8, 2)) }
func AutoNewCounter(s *C.Segment) Counter  { return Counter(s.NewStructAR(8, 2)) }
func ReadRootCounter(s *C.Segment) Counter { return Counter(s.Root(0).ToStruct()) }
func (s Counter) Size() int64              { return int64(C.Struct(s).Get64(0)) }
func (s Counter) SetSize(v int64)          { C.Struct(s).Set64(0, uint64(v)) }
func (s Counter) Words() string            { return C.Struct(s).GetObject(0).ToText() }
func (s Counter) WordsBytes() []byte       { return C.Struct(s).GetObject(0).ToDataTrimLastByte() }
func (s Counter) SetWords(v string)        { C.Struct(s).SetObject(0, s.Segment.NewText(v)) }
func (s Counter) Wordlist() C.TextList     { return C.TextList(C.Struct(s).GetObject(1)) }
func (s Counter) SetWordlist(v C.TextList) { C.Struct(s).SetObject(1, C.Object(v)) }

type Counter_List C.PointerList

func NewCounterList(s *C.Segment, sz int) Counter_List {
	return Counter_List(s.NewCompositeList(8, 2, sz))
}
func (s Counter_List) Len() int         { return C.PointerList(s).Len() }
func (s Counter_List) At(i int) Counter { return Counter(C.PointerList(s).At(i).ToStruct()) }
func (s Counter_List) ToArray() []Counter {
	n := s.Len()
	a := make([]Counter, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Counter_List) Set(i int, item Counter) { C.PointerList(s).Set(i, C.Object(item)) }

type Counter_Struct struct {
	Size     int64
	Words    string
	Wordlist []string
}

func (s Counter) Struct() *Counter_Struct {
	t := &Counter_Struct{}
	t.Size = s.Size()
	t.Words = s.Words()
	for i := 0; i < s.Wordlist().Len(); i++ {
		t.Wordlist = append(t.Wordlist, s.Wordlist().At(i))
	}
	return t
}
func (s Counter) LoadStruct(t *Counter_Struct) {
	if t == nil {
		return
	}
	s.SetSize(t.Size)
	s.SetWords(t.Words)
	s.SetWordlist(s.Segment.NewTextList(len(t.Wordlist)))
	for i := 0; i < len(t.Wordlist); i++ {
		s.Wordlist().Set(i, t.Wordlist[i])
	}
}
func (s *Counter_Struct) Copy() *Counter_Struct {
	t := &Counter_Struct{}
	t.Size = s.Size
	t.Words = s.Words
	for _, e := range s.Wordlist {
		t.Wordlist = append(t.Wordlist, e)
	}
	return t
}
func (s *Counter_Struct) Capnp(seg *C.Segment) Counter {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewCounter(seg)
	t.LoadStruct(s)
	return t
}
func (s *Counter_Struct) RootCapnp(seg *C.Segment) Counter {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootCounter(seg)
	t.LoadStruct(s)
	return t
}
func (s Counter) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"size\":")
		if err != nil {
			return err
		}
		{
			s := s.Size()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"words\":")
		if err != nil {
			return err
		}
		{
			s := s.Words()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"wordlist\":")
		if err != nil {
			return err
		}
		{
			s := s.Wordlist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Counter) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Counter) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("size = ")
	if err != nil {
		return err
	}
	{
		s := s.Size()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("words = ")
	if err != nil {
		return err
	}
	{
		s := s.Words()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("wordlist = ")
	if err != nil {
		return err
	}
	{
		s := s.Wordlist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Counter) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewCounterFromCapLit(s *C.Segment, b []byte) (p Counter, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewCounter(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootCounterFromCapLit(s *C.Segment, b []byte) (p Counter, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootCounter(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Counter) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["size"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetSize(t)
	}
	if fn, ok := sv["words"]; ok {
		_ = fn
		t, ok := fn.Val.(string)
		if !ok {
			return fmt.Errorf("expected 'string' but didn't matched")
		}
		_ = t
		s.SetWords(t)
	}
	if fn, ok := sv["wordlist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewTextList(len(lv))
		for i, en := range lv {
			_ = en
			ev, ok := en.Val.(string)
			if !ok {
				return fmt.Errorf("expected 'string' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetWordlist(t)
	}
	return err
}
func (s Counter_List) FilterIndex(f func(i int, x Counter) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Counter_List) Each(f func(i int, x Counter) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Counter_List) Find(f func(i int, x Counter) bool) (Counter, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Counter{}, false
}
func (s Counter) Seg() *C.Segment {
	return s.Segment
}
func (s Counter) LitName() string {
	return "Counter"
}

type Bag C.Struct

func NewBag(s *C.Segment) Bag      { return Bag(s.NewStruct(0, 1)) }
func NewRootBag(s *C.Segment) Bag  { return Bag(s.NewRootStruct(0, 1)) }
func AutoNewBag(s *C.Segment) Bag  { return Bag(s.NewStructAR(0, 1)) }
func ReadRootBag(s *C.Segment) Bag { return Bag(s.Root(0).ToStruct()) }
func (s Bag) Counter() Counter     { return Counter(C.Struct(s).GetObject(0).ToStruct()) }
func (s Bag) SetCounter(v Counter) { C.Struct(s).SetObject(0, C.Object(v)) }

type Bag_List C.PointerList

func NewBagList(s *C.Segment, sz int) Bag_List { return Bag_List(s.NewCompositeList(0, 1, sz)) }
func (s Bag_List) Len() int                    { return C.PointerList(s).Len() }
func (s Bag_List) At(i int) Bag                { return Bag(C.PointerList(s).At(i).ToStruct()) }
func (s Bag_List) ToArray() []Bag {
	n := s.Len()
	a := make([]Bag, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Bag_List) Set(i int, item Bag) { C.PointerList(s).Set(i, C.Object(item)) }

type Bag_Struct struct {
	Counter *Counter_Struct
}

func (s Bag) Struct() *Bag_Struct {
	t := &Bag_Struct{}
	{
		t.Counter = s.Counter().Struct()
	}
	return t
}
func (s Bag) LoadStruct(t *Bag_Struct) {
	if t == nil {
		return
	}
	{
		p := NewCounter(s.Segment)
		p.LoadStruct(t.Counter)
		s.SetCounter(p)
	}
}
func (s *Bag_Struct) Copy() *Bag_Struct {
	t := &Bag_Struct{}
	if s.Counter != nil {
		t.Counter = s.Counter.Copy()
	}
	return t
}
func (s *Bag_Struct) Capnp(seg *C.Segment) Bag {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewBag(seg)
	t.LoadStruct(s)
	return t
}
func (s *Bag_Struct) RootCapnp(seg *C.Segment) Bag {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootBag(seg)
	t.LoadStruct(s)
	return t
}
func (s Bag) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"counter\":")
		if err != nil {
			return err
		}
		{
			s := s.Counter()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Bag) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Bag) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("counter = ")
	if err != nil {
		return err
	}
	{
		s := s.Counter()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Bag) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewBagFromCapLit(s *C.Segment, b []byte) (p Bag, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewBag(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootBagFromCapLit(s *C.Segment, b []byte) (p Bag, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootBag(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Bag) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["counter"]; ok {
		_ = fn
		t := NewCounter(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetCounter(t)
	}
	return err
}
func (s Bag_List) FilterIndex(f func(i int, x Bag) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Bag_List) Each(f func(i int, x Bag) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Bag_List) Find(f func(i int, x Bag) bool) (Bag, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Bag{}, false
}
func (s Bag) Seg() *C.Segment {
	return s.Segment
}
func (s Bag) LitName() string {
	return "Bag"
}

type Zserver C.Struct

func NewZserver(s *C.Segment) Zserver        { return Zserver(s.NewStruct(0, 1)) }
func NewRootZserver(s *C.Segment) Zserver    { return Zserver(s.NewRootStruct(0, 1)) }
func AutoNewZserver(s *C.Segment) Zserver    { return Zserver(s.NewStructAR(0, 1)) }
func ReadRootZserver(s *C.Segment) Zserver   { return Zserver(s.Root(0).ToStruct()) }
func (s Zserver) Waitingjobs() Zjob_List     { return Zjob_List(C.Struct(s).GetObject(0)) }
func (s Zserver) SetWaitingjobs(v Zjob_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type Zserver_List C.PointerList

func NewZserverList(s *C.Segment, sz int) Zserver_List {
	return Zserver_List(s.NewCompositeList(0, 1, sz))
}
func (s Zserver_List) Len() int         { return C.PointerList(s).Len() }
func (s Zserver_List) At(i int) Zserver { return Zserver(C.PointerList(s).At(i).ToStruct()) }
func (s Zserver_List) ToArray() []Zserver {
	n := s.Len()
	a := make([]Zserver, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Zserver_List) Set(i int, item Zserver) { C.PointerList(s).Set(i, C.Object(item)) }

type Zserver_Struct struct {
	Waitingjobs []*Zjob_Struct
}

func (s Zserver) Struct() *Zserver_Struct {
	t := &Zserver_Struct{}
	for i := 0; i < s.Waitingjobs().Len(); i++ {
		elem := s.Waitingjobs().At(i).Struct()
		t.Waitingjobs = append(t.Waitingjobs, elem)
	}
	return t
}
func (s Zserver) LoadStruct(t *Zserver_Struct) {
	if t == nil {
		return
	}
	s.SetWaitingjobs(NewZjobList(s.Segment, len(t.Waitingjobs)))
	for i := 0; i < len(t.Waitingjobs); i++ {
		s.Waitingjobs().Set(i, t.Waitingjobs[i].Capnp(s.Segment))
	}
}
func (s *Zserver_Struct) Copy() *Zserver_Struct {
	t := &Zserver_Struct{}
	for _, e := range s.Waitingjobs {
		if e != nil {
			t.Waitingjobs = append(t.Waitingjobs, e.Copy())
		} else {
			t.Waitingjobs = append(t.Waitingjobs, nil)
		}
	}
	return t
}
func (s *Zserver_Struct) Capnp(seg *C.Segment) Zserver {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewZserver(seg)
	t.LoadStruct(s)
	return t
}
func (s *Zserver_Struct) RootCapnp(seg *C.Segment) Zserver {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootZserver(seg)
	t.LoadStruct(s)
	return t
}
func (s Zserver) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"waitingjobs\":")
		if err != nil {
			return err
		}
		{
			s := s.Waitingjobs()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zserver) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Zserver) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("waitingjobs = ")
	if err != nil {
		return err
	}
	{
		s := s.Waitingjobs()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zserver) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewZserverFromCapLit(s *C.Segment, b []byte) (p Zserver, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewZserver(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootZserverFromCapLit(s *C.Segment, b []byte) (p Zserver, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootZserver(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Zserver) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["waitingjobs"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewZjobList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewZjob(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetWaitingjobs(t)
	}
	return err
}
func (s Zserver_List) FilterIndex(f func(i int, x Zserver) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Zserver_List) Each(f func(i int, x Zserver) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Zserver_List) Find(f func(i int, x Zserver) bool) (Zserver, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Zserver{}, false
}
func (s Zserver) Seg() *C.Segment {
	return s.Segment
}
func (s Zserver) LitName() string {
	return "Zserver"
}

type Zjob C.Struct

func NewZjob(s *C.Segment) Zjob      { return Zjob(s.NewStruct(0, 2)) }
func NewRootZjob(s *C.Segment) Zjob  { return Zjob(s.NewRootStruct(0, 2)) }
func AutoNewZjob(s *C.Segment) Zjob  { return Zjob(s.NewStructAR(0, 2)) }
func ReadRootZjob(s *C.Segment) Zjob { return Zjob(s.Root(0).ToStruct()) }
func (s Zjob) Cmd() string           { return C.Struct(s).GetObject(0).ToText() }
func (s Zjob) CmdBytes() []byte      { return C.Struct(s).GetObject(0).ToDataTrimLastByte() }
func (s Zjob) SetCmd(v string)       { C.Struct(s).SetObject(0, s.Segment.NewText(v)) }
func (s Zjob) Args() C.TextList      { return C.TextList(C.Struct(s).GetObject(1)) }
func (s Zjob) SetArgs(v C.TextList)  { C.Struct(s).SetObject(1, C.Object(v)) }

type Zjob_List C.PointerList

func NewZjobList(s *C.Segment, sz int) Zjob_List { return Zjob_List(s.NewCompositeList(0, 2, sz)) }
func (s Zjob_List) Len() int                     { return C.PointerList(s).Len() }
func (s Zjob_List) At(i int) Zjob                { return Zjob(C.PointerList(s).At(i).ToStruct()) }
func (s Zjob_List) ToArray() []Zjob {
	n := s.Len()
	a := make([]Zjob, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Zjob_List) Set(i int, item Zjob) { C.PointerList(s).Set(i, C.Object(item)) }

type Zjob_Struct struct {
	Cmd  string
	Args []string
}

func (s Zjob) Struct() *Zjob_Struct {
	t := &Zjob_Struct{}
	t.Cmd = s.Cmd()
	for i := 0; i < s.Args().Len(); i++ {
		t.Args = append(t.Args, s.Args().At(i))
	}
	return t
}
func (s Zjob) LoadStruct(t *Zjob_Struct) {
	if t == nil {
		return
	}
	s.SetCmd(t.Cmd)
	s.SetArgs(s.Segment.NewTextList(len(t.Args)))
	for i := 0; i < len(t.Args); i++ {
		s.Args().Set(i, t.Args[i])
	}
}
func (s *Zjob_Struct) Copy() *Zjob_Struct {
	t := &Zjob_Struct{}
	t.Cmd = s.Cmd
	for _, e := range s.Args {
		t.Args = append(t.Args, e)
	}
	return t
}
func (s *Zjob_Struct) Capnp(seg *C.Segment) Zjob {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewZjob(seg)
	t.LoadStruct(s)
	return t
}
func (s *Zjob_Struct) RootCapnp(seg *C.Segment) Zjob {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootZjob(seg)
	t.LoadStruct(s)
	return t
}
func (s Zjob) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"cmd\":")
		if err != nil {
			return err
		}
		{
			s := s.Cmd()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"args\":")
		if err != nil {
			return err
		}
		{
			s := s.Args()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zjob) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Zjob) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("cmd = ")
	if err != nil {
		return err
	}
	{
		s := s.Cmd()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("args = ")
	if err != nil {
		return err
	}
	{
		s := s.Args()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Zjob) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewZjobFromCapLit(s *C.Segment, b []byte) (p Zjob, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewZjob(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootZjobFromCapLit(s *C.Segment, b []byte) (p Zjob, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootZjob(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Zjob) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["cmd"]; ok {
		_ = fn
		t, ok := fn.Val.(string)
		if !ok {
			return fmt.Errorf("expected 'string' but didn't matched")
		}
		_ = t
		s.SetCmd(t)
	}
	if fn, ok := sv["args"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewTextList(len(lv))
		for i, en := range lv {
			_ = en
			ev, ok := en.Val.(string)
			if !ok {
				return fmt.Errorf("expected 'string' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetArgs(t)
	}
	return err
}
func (s Zjob_List) FilterIndex(f func(i int, x Zjob) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Zjob_List) Each(f func(i int, x Zjob) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Zjob_List) Find(f func(i int, x Zjob) bool) (Zjob, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Zjob{}, false
}
func (s Zjob) Seg() *C.Segment {
	return s.Segment
}
func (s Zjob) LitName() string {
	return "Zjob"
}

type VerEmpty C.Struct

func NewVerEmpty(s *C.Segment) VerEmpty      { return VerEmpty(s.NewStruct(0, 0)) }
func NewRootVerEmpty(s *C.Segment) VerEmpty  { return VerEmpty(s.NewRootStruct(0, 0)) }
func AutoNewVerEmpty(s *C.Segment) VerEmpty  { return VerEmpty(s.NewStructAR(0, 0)) }
func ReadRootVerEmpty(s *C.Segment) VerEmpty { return VerEmpty(s.Root(0).ToStruct()) }

type VerEmpty_List C.PointerList

func NewVerEmptyList(s *C.Segment, sz int) VerEmpty_List {
	return VerEmpty_List(s.NewCompositeList(0, 0, sz))
}
func (s VerEmpty_List) Len() int          { return C.PointerList(s).Len() }
func (s VerEmpty_List) At(i int) VerEmpty { return VerEmpty(C.PointerList(s).At(i).ToStruct()) }
func (s VerEmpty_List) ToArray() []VerEmpty {
	n := s.Len()
	a := make([]VerEmpty, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VerEmpty_List) Set(i int, item VerEmpty) { C.PointerList(s).Set(i, C.Object(item)) }

type VerEmpty_Struct struct {
}

func (s VerEmpty) Struct() *VerEmpty_Struct {
	t := &VerEmpty_Struct{}

	return t
}
func (s VerEmpty) LoadStruct(t *VerEmpty_Struct) {
	if t == nil {
		return
	}

}
func (s *VerEmpty_Struct) Copy() *VerEmpty_Struct {
	t := &VerEmpty_Struct{}

	return t
}
func (s *VerEmpty_Struct) Capnp(seg *C.Segment) VerEmpty {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVerEmpty(seg)
	t.LoadStruct(s)
	return t
}
func (s *VerEmpty_Struct) RootCapnp(seg *C.Segment) VerEmpty {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVerEmpty(seg)
	t.LoadStruct(s)
	return t
}
func (s VerEmpty) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerEmpty) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VerEmpty) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerEmpty) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVerEmptyFromCapLit(s *C.Segment, b []byte) (p VerEmpty, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVerEmpty(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVerEmptyFromCapLit(s *C.Segment, b []byte) (p VerEmpty, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVerEmpty(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VerEmpty) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv

	return err
}
func (s VerEmpty_List) FilterIndex(f func(i int, x VerEmpty) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VerEmpty_List) Each(f func(i int, x VerEmpty) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VerEmpty_List) Find(f func(i int, x VerEmpty) bool) (VerEmpty, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VerEmpty{}, false
}
func (s VerEmpty) Seg() *C.Segment {
	return s.Segment
}
func (s VerEmpty) LitName() string {
	return "VerEmpty"
}

type VerOneData C.Struct

func NewVerOneData(s *C.Segment) VerOneData      { return VerOneData(s.NewStruct(8, 0)) }
func NewRootVerOneData(s *C.Segment) VerOneData  { return VerOneData(s.NewRootStruct(8, 0)) }
func AutoNewVerOneData(s *C.Segment) VerOneData  { return VerOneData(s.NewStructAR(8, 0)) }
func ReadRootVerOneData(s *C.Segment) VerOneData { return VerOneData(s.Root(0).ToStruct()) }
func (s VerOneData) Val() int16                  { return int16(C.Struct(s).Get16(0)) }
func (s VerOneData) SetVal(v int16)              { C.Struct(s).Set16(0, uint16(v)) }

type VerOneData_List C.PointerList

func NewVerOneDataList(s *C.Segment, sz int) VerOneData_List {
	return VerOneData_List(s.NewCompositeList(8, 0, sz))
}
func (s VerOneData_List) Len() int            { return C.PointerList(s).Len() }
func (s VerOneData_List) At(i int) VerOneData { return VerOneData(C.PointerList(s).At(i).ToStruct()) }
func (s VerOneData_List) ToArray() []VerOneData {
	n := s.Len()
	a := make([]VerOneData, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VerOneData_List) Set(i int, item VerOneData) { C.PointerList(s).Set(i, C.Object(item)) }

type VerOneData_Struct struct {
	Val int16
}

func (s VerOneData) Struct() *VerOneData_Struct {
	t := &VerOneData_Struct{}
	t.Val = s.Val()
	return t
}
func (s VerOneData) LoadStruct(t *VerOneData_Struct) {
	if t == nil {
		return
	}
	s.SetVal(t.Val)
}
func (s *VerOneData_Struct) Copy() *VerOneData_Struct {
	t := &VerOneData_Struct{}
	t.Val = s.Val
	return t
}
func (s *VerOneData_Struct) Capnp(seg *C.Segment) VerOneData {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVerOneData(seg)
	t.LoadStruct(s)
	return t
}
func (s *VerOneData_Struct) RootCapnp(seg *C.Segment) VerOneData {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVerOneData(seg)
	t.LoadStruct(s)
	return t
}
func (s VerOneData) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"val\":")
		if err != nil {
			return err
		}
		{
			s := s.Val()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerOneData) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VerOneData) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("val = ")
	if err != nil {
		return err
	}
	{
		s := s.Val()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerOneData) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVerOneDataFromCapLit(s *C.Segment, b []byte) (p VerOneData, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVerOneData(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVerOneDataFromCapLit(s *C.Segment, b []byte) (p VerOneData, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVerOneData(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VerOneData) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["val"]; ok {
		_ = fn
		var t int16
		if temp, ok := fn.Val.(int64); ok {
			t = int16(temp)
		} else {
			return fmt.Errorf("expected 'int16' but didn't matched")
		}
		_ = t
		s.SetVal(t)
	}
	return err
}
func (s VerOneData_List) FilterIndex(f func(i int, x VerOneData) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VerOneData_List) Each(f func(i int, x VerOneData) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VerOneData_List) Find(f func(i int, x VerOneData) bool) (VerOneData, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VerOneData{}, false
}
func (s VerOneData) Seg() *C.Segment {
	return s.Segment
}
func (s VerOneData) LitName() string {
	return "VerOneData"
}

type VerTwoData C.Struct

func NewVerTwoData(s *C.Segment) VerTwoData      { return VerTwoData(s.NewStruct(16, 0)) }
func NewRootVerTwoData(s *C.Segment) VerTwoData  { return VerTwoData(s.NewRootStruct(16, 0)) }
func AutoNewVerTwoData(s *C.Segment) VerTwoData  { return VerTwoData(s.NewStructAR(16, 0)) }
func ReadRootVerTwoData(s *C.Segment) VerTwoData { return VerTwoData(s.Root(0).ToStruct()) }
func (s VerTwoData) Val() int16                  { return int16(C.Struct(s).Get16(0)) }
func (s VerTwoData) SetVal(v int16)              { C.Struct(s).Set16(0, uint16(v)) }
func (s VerTwoData) Duo() int64                  { return int64(C.Struct(s).Get64(8)) }
func (s VerTwoData) SetDuo(v int64)              { C.Struct(s).Set64(8, uint64(v)) }

type VerTwoData_List C.PointerList

func NewVerTwoDataList(s *C.Segment, sz int) VerTwoData_List {
	return VerTwoData_List(s.NewCompositeList(16, 0, sz))
}
func (s VerTwoData_List) Len() int            { return C.PointerList(s).Len() }
func (s VerTwoData_List) At(i int) VerTwoData { return VerTwoData(C.PointerList(s).At(i).ToStruct()) }
func (s VerTwoData_List) ToArray() []VerTwoData {
	n := s.Len()
	a := make([]VerTwoData, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VerTwoData_List) Set(i int, item VerTwoData) { C.PointerList(s).Set(i, C.Object(item)) }

type VerTwoData_Struct struct {
	Val int16
	Duo int64
}

func (s VerTwoData) Struct() *VerTwoData_Struct {
	t := &VerTwoData_Struct{}
	t.Val = s.Val()
	t.Duo = s.Duo()
	return t
}
func (s VerTwoData) LoadStruct(t *VerTwoData_Struct) {
	if t == nil {
		return
	}
	s.SetVal(t.Val)
	s.SetDuo(t.Duo)
}
func (s *VerTwoData_Struct) Copy() *VerTwoData_Struct {
	t := &VerTwoData_Struct{}
	t.Val = s.Val
	t.Duo = s.Duo
	return t
}
func (s *VerTwoData_Struct) Capnp(seg *C.Segment) VerTwoData {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVerTwoData(seg)
	t.LoadStruct(s)
	return t
}
func (s *VerTwoData_Struct) RootCapnp(seg *C.Segment) VerTwoData {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVerTwoData(seg)
	t.LoadStruct(s)
	return t
}
func (s VerTwoData) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"val\":")
		if err != nil {
			return err
		}
		{
			s := s.Val()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"duo\":")
		if err != nil {
			return err
		}
		{
			s := s.Duo()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoData) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VerTwoData) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("val = ")
	if err != nil {
		return err
	}
	{
		s := s.Val()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("duo = ")
	if err != nil {
		return err
	}
	{
		s := s.Duo()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoData) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVerTwoDataFromCapLit(s *C.Segment, b []byte) (p VerTwoData, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVerTwoData(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVerTwoDataFromCapLit(s *C.Segment, b []byte) (p VerTwoData, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVerTwoData(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VerTwoData) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["val"]; ok {
		_ = fn
		var t int16
		if temp, ok := fn.Val.(int64); ok {
			t = int16(temp)
		} else {
			return fmt.Errorf("expected 'int16' but didn't matched")
		}
		_ = t
		s.SetVal(t)
	}
	if fn, ok := sv["duo"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetDuo(t)
	}
	return err
}
func (s VerTwoData_List) FilterIndex(f func(i int, x VerTwoData) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VerTwoData_List) Each(f func(i int, x VerTwoData) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VerTwoData_List) Find(f func(i int, x VerTwoData) bool) (VerTwoData, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VerTwoData{}, false
}
func (s VerTwoData) Seg() *C.Segment {
	return s.Segment
}
func (s VerTwoData) LitName() string {
	return "VerTwoData"
}

type VerOnePtr C.Struct

func NewVerOnePtr(s *C.Segment) VerOnePtr      { return VerOnePtr(s.NewStruct(0, 1)) }
func NewRootVerOnePtr(s *C.Segment) VerOnePtr  { return VerOnePtr(s.NewRootStruct(0, 1)) }
func AutoNewVerOnePtr(s *C.Segment) VerOnePtr  { return VerOnePtr(s.NewStructAR(0, 1)) }
func ReadRootVerOnePtr(s *C.Segment) VerOnePtr { return VerOnePtr(s.Root(0).ToStruct()) }
func (s VerOnePtr) Ptr() VerOneData            { return VerOneData(C.Struct(s).GetObject(0).ToStruct()) }
func (s VerOnePtr) SetPtr(v VerOneData)        { C.Struct(s).SetObject(0, C.Object(v)) }

type VerOnePtr_List C.PointerList

func NewVerOnePtrList(s *C.Segment, sz int) VerOnePtr_List {
	return VerOnePtr_List(s.NewCompositeList(0, 1, sz))
}
func (s VerOnePtr_List) Len() int           { return C.PointerList(s).Len() }
func (s VerOnePtr_List) At(i int) VerOnePtr { return VerOnePtr(C.PointerList(s).At(i).ToStruct()) }
func (s VerOnePtr_List) ToArray() []VerOnePtr {
	n := s.Len()
	a := make([]VerOnePtr, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VerOnePtr_List) Set(i int, item VerOnePtr) { C.PointerList(s).Set(i, C.Object(item)) }

type VerOnePtr_Struct struct {
	Ptr *VerOneData_Struct
}

func (s VerOnePtr) Struct() *VerOnePtr_Struct {
	t := &VerOnePtr_Struct{}
	{
		t.Ptr = s.Ptr().Struct()
	}
	return t
}
func (s VerOnePtr) LoadStruct(t *VerOnePtr_Struct) {
	if t == nil {
		return
	}
	{
		p := NewVerOneData(s.Segment)
		p.LoadStruct(t.Ptr)
		s.SetPtr(p)
	}
}
func (s *VerOnePtr_Struct) Copy() *VerOnePtr_Struct {
	t := &VerOnePtr_Struct{}
	if s.Ptr != nil {
		t.Ptr = s.Ptr.Copy()
	}
	return t
}
func (s *VerOnePtr_Struct) Capnp(seg *C.Segment) VerOnePtr {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVerOnePtr(seg)
	t.LoadStruct(s)
	return t
}
func (s *VerOnePtr_Struct) RootCapnp(seg *C.Segment) VerOnePtr {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVerOnePtr(seg)
	t.LoadStruct(s)
	return t
}
func (s VerOnePtr) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ptr\":")
		if err != nil {
			return err
		}
		{
			s := s.Ptr()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerOnePtr) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VerOnePtr) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("ptr = ")
	if err != nil {
		return err
	}
	{
		s := s.Ptr()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerOnePtr) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVerOnePtrFromCapLit(s *C.Segment, b []byte) (p VerOnePtr, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVerOnePtr(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVerOnePtrFromCapLit(s *C.Segment, b []byte) (p VerOnePtr, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVerOnePtr(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VerOnePtr) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["ptr"]; ok {
		_ = fn
		t := NewVerOneData(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPtr(t)
	}
	return err
}
func (s VerOnePtr_List) FilterIndex(f func(i int, x VerOnePtr) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VerOnePtr_List) Each(f func(i int, x VerOnePtr) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VerOnePtr_List) Find(f func(i int, x VerOnePtr) bool) (VerOnePtr, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VerOnePtr{}, false
}
func (s VerOnePtr) Seg() *C.Segment {
	return s.Segment
}
func (s VerOnePtr) LitName() string {
	return "VerOnePtr"
}

type VerTwoPtr C.Struct

func NewVerTwoPtr(s *C.Segment) VerTwoPtr      { return VerTwoPtr(s.NewStruct(0, 2)) }
func NewRootVerTwoPtr(s *C.Segment) VerTwoPtr  { return VerTwoPtr(s.NewRootStruct(0, 2)) }
func AutoNewVerTwoPtr(s *C.Segment) VerTwoPtr  { return VerTwoPtr(s.NewStructAR(0, 2)) }
func ReadRootVerTwoPtr(s *C.Segment) VerTwoPtr { return VerTwoPtr(s.Root(0).ToStruct()) }
func (s VerTwoPtr) Ptr1() VerOneData           { return VerOneData(C.Struct(s).GetObject(0).ToStruct()) }
func (s VerTwoPtr) SetPtr1(v VerOneData)       { C.Struct(s).SetObject(0, C.Object(v)) }
func (s VerTwoPtr) Ptr2() VerOneData           { return VerOneData(C.Struct(s).GetObject(1).ToStruct()) }
func (s VerTwoPtr) SetPtr2(v VerOneData)       { C.Struct(s).SetObject(1, C.Object(v)) }

type VerTwoPtr_List C.PointerList

func NewVerTwoPtrList(s *C.Segment, sz int) VerTwoPtr_List {
	return VerTwoPtr_List(s.NewCompositeList(0, 2, sz))
}
func (s VerTwoPtr_List) Len() int           { return C.PointerList(s).Len() }
func (s VerTwoPtr_List) At(i int) VerTwoPtr { return VerTwoPtr(C.PointerList(s).At(i).ToStruct()) }
func (s VerTwoPtr_List) ToArray() []VerTwoPtr {
	n := s.Len()
	a := make([]VerTwoPtr, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VerTwoPtr_List) Set(i int, item VerTwoPtr) { C.PointerList(s).Set(i, C.Object(item)) }

type VerTwoPtr_Struct struct {
	Ptr1 *VerOneData_Struct
	Ptr2 *VerOneData_Struct
}

func (s VerTwoPtr) Struct() *VerTwoPtr_Struct {
	t := &VerTwoPtr_Struct{}
	{
		t.Ptr1 = s.Ptr1().Struct()
	}
	{
		t.Ptr2 = s.Ptr2().Struct()
	}
	return t
}
func (s VerTwoPtr) LoadStruct(t *VerTwoPtr_Struct) {
	if t == nil {
		return
	}
	{
		p := NewVerOneData(s.Segment)
		p.LoadStruct(t.Ptr1)
		s.SetPtr1(p)
	}
	{
		p := NewVerOneData(s.Segment)
		p.LoadStruct(t.Ptr2)
		s.SetPtr2(p)
	}
}
func (s *VerTwoPtr_Struct) Copy() *VerTwoPtr_Struct {
	t := &VerTwoPtr_Struct{}
	if s.Ptr1 != nil {
		t.Ptr1 = s.Ptr1.Copy()
	}
	if s.Ptr2 != nil {
		t.Ptr2 = s.Ptr2.Copy()
	}
	return t
}
func (s *VerTwoPtr_Struct) Capnp(seg *C.Segment) VerTwoPtr {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVerTwoPtr(seg)
	t.LoadStruct(s)
	return t
}
func (s *VerTwoPtr_Struct) RootCapnp(seg *C.Segment) VerTwoPtr {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVerTwoPtr(seg)
	t.LoadStruct(s)
	return t
}
func (s VerTwoPtr) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ptr1\":")
		if err != nil {
			return err
		}
		{
			s := s.Ptr1()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ptr2\":")
		if err != nil {
			return err
		}
		{
			s := s.Ptr2()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoPtr) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VerTwoPtr) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("ptr1 = ")
	if err != nil {
		return err
	}
	{
		s := s.Ptr1()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("ptr2 = ")
	if err != nil {
		return err
	}
	{
		s := s.Ptr2()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoPtr) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVerTwoPtrFromCapLit(s *C.Segment, b []byte) (p VerTwoPtr, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVerTwoPtr(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVerTwoPtrFromCapLit(s *C.Segment, b []byte) (p VerTwoPtr, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVerTwoPtr(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VerTwoPtr) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["ptr1"]; ok {
		_ = fn
		t := NewVerOneData(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPtr1(t)
	}
	if fn, ok := sv["ptr2"]; ok {
		_ = fn
		t := NewVerOneData(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPtr2(t)
	}
	return err
}
func (s VerTwoPtr_List) FilterIndex(f func(i int, x VerTwoPtr) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VerTwoPtr_List) Each(f func(i int, x VerTwoPtr) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VerTwoPtr_List) Find(f func(i int, x VerTwoPtr) bool) (VerTwoPtr, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VerTwoPtr{}, false
}
func (s VerTwoPtr) Seg() *C.Segment {
	return s.Segment
}
func (s VerTwoPtr) LitName() string {
	return "VerTwoPtr"
}

type VerTwoDataTwoPtr C.Struct

func NewVerTwoDataTwoPtr(s *C.Segment) VerTwoDataTwoPtr { return VerTwoDataTwoPtr(s.NewStruct(16, 2)) }
func NewRootVerTwoDataTwoPtr(s *C.Segment) VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(s.NewRootStruct(16, 2))
}
func AutoNewVerTwoDataTwoPtr(s *C.Segment) VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(s.NewStructAR(16, 2))
}
func ReadRootVerTwoDataTwoPtr(s *C.Segment) VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(s.Root(0).ToStruct())
}
func (s VerTwoDataTwoPtr) Val() int16           { return int16(C.Struct(s).Get16(0)) }
func (s VerTwoDataTwoPtr) SetVal(v int16)       { C.Struct(s).Set16(0, uint16(v)) }
func (s VerTwoDataTwoPtr) Duo() int64           { return int64(C.Struct(s).Get64(8)) }
func (s VerTwoDataTwoPtr) SetDuo(v int64)       { C.Struct(s).Set64(8, uint64(v)) }
func (s VerTwoDataTwoPtr) Ptr1() VerOneData     { return VerOneData(C.Struct(s).GetObject(0).ToStruct()) }
func (s VerTwoDataTwoPtr) SetPtr1(v VerOneData) { C.Struct(s).SetObject(0, C.Object(v)) }
func (s VerTwoDataTwoPtr) Ptr2() VerOneData     { return VerOneData(C.Struct(s).GetObject(1).ToStruct()) }
func (s VerTwoDataTwoPtr) SetPtr2(v VerOneData) { C.Struct(s).SetObject(1, C.Object(v)) }

type VerTwoDataTwoPtr_List C.PointerList

func NewVerTwoDataTwoPtrList(s *C.Segment, sz int) VerTwoDataTwoPtr_List {
	return VerTwoDataTwoPtr_List(s.NewCompositeList(16, 2, sz))
}
func (s VerTwoDataTwoPtr_List) Len() int { return C.PointerList(s).Len() }
func (s VerTwoDataTwoPtr_List) At(i int) VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(C.PointerList(s).At(i).ToStruct())
}
func (s VerTwoDataTwoPtr_List) ToArray() []VerTwoDataTwoPtr {
	n := s.Len()
	a := make([]VerTwoDataTwoPtr, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VerTwoDataTwoPtr_List) Set(i int, item VerTwoDataTwoPtr) {
	C.PointerList(s).Set(i, C.Object(item))
}

type VerTwoDataTwoPtr_Struct struct {
	Val  int16
	Duo  int64
	Ptr1 *VerOneData_Struct
	Ptr2 *VerOneData_Struct
}

func (s VerTwoDataTwoPtr) Struct() *VerTwoDataTwoPtr_Struct {
	t := &VerTwoDataTwoPtr_Struct{}
	t.Val = s.Val()
	t.Duo = s.Duo()
	{
		t.Ptr1 = s.Ptr1().Struct()
	}
	{
		t.Ptr2 = s.Ptr2().Struct()
	}
	return t
}
func (s VerTwoDataTwoPtr) LoadStruct(t *VerTwoDataTwoPtr_Struct) {
	if t == nil {
		return
	}
	s.SetVal(t.Val)
	s.SetDuo(t.Duo)
	{
		p := NewVerOneData(s.Segment)
		p.LoadStruct(t.Ptr1)
		s.SetPtr1(p)
	}
	{
		p := NewVerOneData(s.Segment)
		p.LoadStruct(t.Ptr2)
		s.SetPtr2(p)
	}
}
func (s *VerTwoDataTwoPtr_Struct) Copy() *VerTwoDataTwoPtr_Struct {
	t := &VerTwoDataTwoPtr_Struct{}
	t.Val = s.Val
	t.Duo = s.Duo
	if s.Ptr1 != nil {
		t.Ptr1 = s.Ptr1.Copy()
	}
	if s.Ptr2 != nil {
		t.Ptr2 = s.Ptr2.Copy()
	}
	return t
}
func (s *VerTwoDataTwoPtr_Struct) Capnp(seg *C.Segment) VerTwoDataTwoPtr {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVerTwoDataTwoPtr(seg)
	t.LoadStruct(s)
	return t
}
func (s *VerTwoDataTwoPtr_Struct) RootCapnp(seg *C.Segment) VerTwoDataTwoPtr {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVerTwoDataTwoPtr(seg)
	t.LoadStruct(s)
	return t
}
func (s VerTwoDataTwoPtr) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"val\":")
		if err != nil {
			return err
		}
		{
			s := s.Val()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"duo\":")
		if err != nil {
			return err
		}
		{
			s := s.Duo()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ptr1\":")
		if err != nil {
			return err
		}
		{
			s := s.Ptr1()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ptr2\":")
		if err != nil {
			return err
		}
		{
			s := s.Ptr2()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoDataTwoPtr) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VerTwoDataTwoPtr) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("val = ")
	if err != nil {
		return err
	}
	{
		s := s.Val()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("duo = ")
	if err != nil {
		return err
	}
	{
		s := s.Duo()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("ptr1 = ")
	if err != nil {
		return err
	}
	{
		s := s.Ptr1()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("ptr2 = ")
	if err != nil {
		return err
	}
	{
		s := s.Ptr2()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoDataTwoPtr) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVerTwoDataTwoPtrFromCapLit(s *C.Segment, b []byte) (p VerTwoDataTwoPtr, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVerTwoDataTwoPtr(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVerTwoDataTwoPtrFromCapLit(s *C.Segment, b []byte) (p VerTwoDataTwoPtr, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVerTwoDataTwoPtr(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VerTwoDataTwoPtr) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["val"]; ok {
		_ = fn
		var t int16
		if temp, ok := fn.Val.(int64); ok {
			t = int16(temp)
		} else {
			return fmt.Errorf("expected 'int16' but didn't matched")
		}
		_ = t
		s.SetVal(t)
	}
	if fn, ok := sv["duo"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetDuo(t)
	}
	if fn, ok := sv["ptr1"]; ok {
		_ = fn
		t := NewVerOneData(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPtr1(t)
	}
	if fn, ok := sv["ptr2"]; ok {
		_ = fn
		t := NewVerOneData(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPtr2(t)
	}
	return err
}
func (s VerTwoDataTwoPtr_List) FilterIndex(f func(i int, x VerTwoDataTwoPtr) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VerTwoDataTwoPtr_List) Each(f func(i int, x VerTwoDataTwoPtr) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VerTwoDataTwoPtr_List) Find(f func(i int, x VerTwoDataTwoPtr) bool) (VerTwoDataTwoPtr, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VerTwoDataTwoPtr{}, false
}
func (s VerTwoDataTwoPtr) Seg() *C.Segment {
	return s.Segment
}
func (s VerTwoDataTwoPtr) LitName() string {
	return "VerTwoDataTwoPtr"
}

type HoldsVerEmptyList C.Struct

func NewHoldsVerEmptyList(s *C.Segment) HoldsVerEmptyList {
	return HoldsVerEmptyList(s.NewStruct(0, 1))
}
func NewRootHoldsVerEmptyList(s *C.Segment) HoldsVerEmptyList {
	return HoldsVerEmptyList(s.NewRootStruct(0, 1))
}
func AutoNewHoldsVerEmptyList(s *C.Segment) HoldsVerEmptyList {
	return HoldsVerEmptyList(s.NewStructAR(0, 1))
}
func ReadRootHoldsVerEmptyList(s *C.Segment) HoldsVerEmptyList {
	return HoldsVerEmptyList(s.Root(0).ToStruct())
}
func (s HoldsVerEmptyList) Mylist() VerEmpty_List     { return VerEmpty_List(C.Struct(s).GetObject(0)) }
func (s HoldsVerEmptyList) SetMylist(v VerEmpty_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type HoldsVerEmptyList_List C.PointerList

func NewHoldsVerEmptyListList(s *C.Segment, sz int) HoldsVerEmptyList_List {
	return HoldsVerEmptyList_List(s.NewCompositeList(0, 1, sz))
}
func (s HoldsVerEmptyList_List) Len() int { return C.PointerList(s).Len() }
func (s HoldsVerEmptyList_List) At(i int) HoldsVerEmptyList {
	return HoldsVerEmptyList(C.PointerList(s).At(i).ToStruct())
}
func (s HoldsVerEmptyList_List) ToArray() []HoldsVerEmptyList {
	n := s.Len()
	a := make([]HoldsVerEmptyList, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsVerEmptyList_List) Set(i int, item HoldsVerEmptyList) {
	C.PointerList(s).Set(i, C.Object(item))
}

type HoldsVerEmptyList_Struct struct {
	Mylist []*VerEmpty_Struct
}

func (s HoldsVerEmptyList) Struct() *HoldsVerEmptyList_Struct {
	t := &HoldsVerEmptyList_Struct{}
	for i := 0; i < s.Mylist().Len(); i++ {
		elem := s.Mylist().At(i).Struct()
		t.Mylist = append(t.Mylist, elem)
	}
	return t
}
func (s HoldsVerEmptyList) LoadStruct(t *HoldsVerEmptyList_Struct) {
	if t == nil {
		return
	}
	s.SetMylist(NewVerEmptyList(s.Segment, len(t.Mylist)))
	for i := 0; i < len(t.Mylist); i++ {
		s.Mylist().Set(i, t.Mylist[i].Capnp(s.Segment))
	}
}
func (s *HoldsVerEmptyList_Struct) Copy() *HoldsVerEmptyList_Struct {
	t := &HoldsVerEmptyList_Struct{}
	for _, e := range s.Mylist {
		if e != nil {
			t.Mylist = append(t.Mylist, e.Copy())
		} else {
			t.Mylist = append(t.Mylist, nil)
		}
	}
	return t
}
func (s *HoldsVerEmptyList_Struct) Capnp(seg *C.Segment) HoldsVerEmptyList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsVerEmptyList(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsVerEmptyList_Struct) RootCapnp(seg *C.Segment) HoldsVerEmptyList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsVerEmptyList(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsVerEmptyList) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mylist\":")
		if err != nil {
			return err
		}
		{
			s := s.Mylist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerEmptyList) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsVerEmptyList) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mylist = ")
	if err != nil {
		return err
	}
	{
		s := s.Mylist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerEmptyList) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsVerEmptyListFromCapLit(s *C.Segment, b []byte) (p HoldsVerEmptyList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsVerEmptyList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsVerEmptyListFromCapLit(s *C.Segment, b []byte) (p HoldsVerEmptyList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsVerEmptyList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsVerEmptyList) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mylist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewVerEmptyList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewVerEmpty(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetMylist(t)
	}
	return err
}
func (s HoldsVerEmptyList_List) FilterIndex(f func(i int, x HoldsVerEmptyList) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsVerEmptyList_List) Each(f func(i int, x HoldsVerEmptyList) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsVerEmptyList_List) Find(f func(i int, x HoldsVerEmptyList) bool) (HoldsVerEmptyList, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsVerEmptyList{}, false
}
func (s HoldsVerEmptyList) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsVerEmptyList) LitName() string {
	return "HoldsVerEmptyList"
}

type HoldsVerOneDataList C.Struct

func NewHoldsVerOneDataList(s *C.Segment) HoldsVerOneDataList {
	return HoldsVerOneDataList(s.NewStruct(0, 1))
}
func NewRootHoldsVerOneDataList(s *C.Segment) HoldsVerOneDataList {
	return HoldsVerOneDataList(s.NewRootStruct(0, 1))
}
func AutoNewHoldsVerOneDataList(s *C.Segment) HoldsVerOneDataList {
	return HoldsVerOneDataList(s.NewStructAR(0, 1))
}
func ReadRootHoldsVerOneDataList(s *C.Segment) HoldsVerOneDataList {
	return HoldsVerOneDataList(s.Root(0).ToStruct())
}
func (s HoldsVerOneDataList) Mylist() VerOneData_List {
	return VerOneData_List(C.Struct(s).GetObject(0))
}
func (s HoldsVerOneDataList) SetMylist(v VerOneData_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type HoldsVerOneDataList_List C.PointerList

func NewHoldsVerOneDataListList(s *C.Segment, sz int) HoldsVerOneDataList_List {
	return HoldsVerOneDataList_List(s.NewCompositeList(0, 1, sz))
}
func (s HoldsVerOneDataList_List) Len() int { return C.PointerList(s).Len() }
func (s HoldsVerOneDataList_List) At(i int) HoldsVerOneDataList {
	return HoldsVerOneDataList(C.PointerList(s).At(i).ToStruct())
}
func (s HoldsVerOneDataList_List) ToArray() []HoldsVerOneDataList {
	n := s.Len()
	a := make([]HoldsVerOneDataList, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsVerOneDataList_List) Set(i int, item HoldsVerOneDataList) {
	C.PointerList(s).Set(i, C.Object(item))
}

type HoldsVerOneDataList_Struct struct {
	Mylist []*VerOneData_Struct
}

func (s HoldsVerOneDataList) Struct() *HoldsVerOneDataList_Struct {
	t := &HoldsVerOneDataList_Struct{}
	for i := 0; i < s.Mylist().Len(); i++ {
		elem := s.Mylist().At(i).Struct()
		t.Mylist = append(t.Mylist, elem)
	}
	return t
}
func (s HoldsVerOneDataList) LoadStruct(t *HoldsVerOneDataList_Struct) {
	if t == nil {
		return
	}
	s.SetMylist(NewVerOneDataList(s.Segment, len(t.Mylist)))
	for i := 0; i < len(t.Mylist); i++ {
		s.Mylist().Set(i, t.Mylist[i].Capnp(s.Segment))
	}
}
func (s *HoldsVerOneDataList_Struct) Copy() *HoldsVerOneDataList_Struct {
	t := &HoldsVerOneDataList_Struct{}
	for _, e := range s.Mylist {
		if e != nil {
			t.Mylist = append(t.Mylist, e.Copy())
		} else {
			t.Mylist = append(t.Mylist, nil)
		}
	}
	return t
}
func (s *HoldsVerOneDataList_Struct) Capnp(seg *C.Segment) HoldsVerOneDataList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsVerOneDataList(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsVerOneDataList_Struct) RootCapnp(seg *C.Segment) HoldsVerOneDataList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsVerOneDataList(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsVerOneDataList) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mylist\":")
		if err != nil {
			return err
		}
		{
			s := s.Mylist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerOneDataList) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsVerOneDataList) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mylist = ")
	if err != nil {
		return err
	}
	{
		s := s.Mylist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerOneDataList) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsVerOneDataListFromCapLit(s *C.Segment, b []byte) (p HoldsVerOneDataList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsVerOneDataList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsVerOneDataListFromCapLit(s *C.Segment, b []byte) (p HoldsVerOneDataList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsVerOneDataList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsVerOneDataList) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mylist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewVerOneDataList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewVerOneData(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetMylist(t)
	}
	return err
}
func (s HoldsVerOneDataList_List) FilterIndex(f func(i int, x HoldsVerOneDataList) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsVerOneDataList_List) Each(f func(i int, x HoldsVerOneDataList) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsVerOneDataList_List) Find(f func(i int, x HoldsVerOneDataList) bool) (HoldsVerOneDataList, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsVerOneDataList{}, false
}
func (s HoldsVerOneDataList) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsVerOneDataList) LitName() string {
	return "HoldsVerOneDataList"
}

type HoldsVerTwoDataList C.Struct

func NewHoldsVerTwoDataList(s *C.Segment) HoldsVerTwoDataList {
	return HoldsVerTwoDataList(s.NewStruct(0, 1))
}
func NewRootHoldsVerTwoDataList(s *C.Segment) HoldsVerTwoDataList {
	return HoldsVerTwoDataList(s.NewRootStruct(0, 1))
}
func AutoNewHoldsVerTwoDataList(s *C.Segment) HoldsVerTwoDataList {
	return HoldsVerTwoDataList(s.NewStructAR(0, 1))
}
func ReadRootHoldsVerTwoDataList(s *C.Segment) HoldsVerTwoDataList {
	return HoldsVerTwoDataList(s.Root(0).ToStruct())
}
func (s HoldsVerTwoDataList) Mylist() VerTwoData_List {
	return VerTwoData_List(C.Struct(s).GetObject(0))
}
func (s HoldsVerTwoDataList) SetMylist(v VerTwoData_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type HoldsVerTwoDataList_List C.PointerList

func NewHoldsVerTwoDataListList(s *C.Segment, sz int) HoldsVerTwoDataList_List {
	return HoldsVerTwoDataList_List(s.NewCompositeList(0, 1, sz))
}
func (s HoldsVerTwoDataList_List) Len() int { return C.PointerList(s).Len() }
func (s HoldsVerTwoDataList_List) At(i int) HoldsVerTwoDataList {
	return HoldsVerTwoDataList(C.PointerList(s).At(i).ToStruct())
}
func (s HoldsVerTwoDataList_List) ToArray() []HoldsVerTwoDataList {
	n := s.Len()
	a := make([]HoldsVerTwoDataList, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsVerTwoDataList_List) Set(i int, item HoldsVerTwoDataList) {
	C.PointerList(s).Set(i, C.Object(item))
}

type HoldsVerTwoDataList_Struct struct {
	Mylist []*VerTwoData_Struct
}

func (s HoldsVerTwoDataList) Struct() *HoldsVerTwoDataList_Struct {
	t := &HoldsVerTwoDataList_Struct{}
	for i := 0; i < s.Mylist().Len(); i++ {
		elem := s.Mylist().At(i).Struct()
		t.Mylist = append(t.Mylist, elem)
	}
	return t
}
func (s HoldsVerTwoDataList) LoadStruct(t *HoldsVerTwoDataList_Struct) {
	if t == nil {
		return
	}
	s.SetMylist(NewVerTwoDataList(s.Segment, len(t.Mylist)))
	for i := 0; i < len(t.Mylist); i++ {
		s.Mylist().Set(i, t.Mylist[i].Capnp(s.Segment))
	}
}
func (s *HoldsVerTwoDataList_Struct) Copy() *HoldsVerTwoDataList_Struct {
	t := &HoldsVerTwoDataList_Struct{}
	for _, e := range s.Mylist {
		if e != nil {
			t.Mylist = append(t.Mylist, e.Copy())
		} else {
			t.Mylist = append(t.Mylist, nil)
		}
	}
	return t
}
func (s *HoldsVerTwoDataList_Struct) Capnp(seg *C.Segment) HoldsVerTwoDataList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsVerTwoDataList(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsVerTwoDataList_Struct) RootCapnp(seg *C.Segment) HoldsVerTwoDataList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsVerTwoDataList(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsVerTwoDataList) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mylist\":")
		if err != nil {
			return err
		}
		{
			s := s.Mylist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoDataList) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsVerTwoDataList) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mylist = ")
	if err != nil {
		return err
	}
	{
		s := s.Mylist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoDataList) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsVerTwoDataListFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoDataList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsVerTwoDataList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsVerTwoDataListFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoDataList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsVerTwoDataList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsVerTwoDataList) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mylist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewVerTwoDataList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewVerTwoData(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetMylist(t)
	}
	return err
}
func (s HoldsVerTwoDataList_List) FilterIndex(f func(i int, x HoldsVerTwoDataList) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsVerTwoDataList_List) Each(f func(i int, x HoldsVerTwoDataList) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsVerTwoDataList_List) Find(f func(i int, x HoldsVerTwoDataList) bool) (HoldsVerTwoDataList, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsVerTwoDataList{}, false
}
func (s HoldsVerTwoDataList) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsVerTwoDataList) LitName() string {
	return "HoldsVerTwoDataList"
}

type HoldsVerOnePtrList C.Struct

func NewHoldsVerOnePtrList(s *C.Segment) HoldsVerOnePtrList {
	return HoldsVerOnePtrList(s.NewStruct(0, 1))
}
func NewRootHoldsVerOnePtrList(s *C.Segment) HoldsVerOnePtrList {
	return HoldsVerOnePtrList(s.NewRootStruct(0, 1))
}
func AutoNewHoldsVerOnePtrList(s *C.Segment) HoldsVerOnePtrList {
	return HoldsVerOnePtrList(s.NewStructAR(0, 1))
}
func ReadRootHoldsVerOnePtrList(s *C.Segment) HoldsVerOnePtrList {
	return HoldsVerOnePtrList(s.Root(0).ToStruct())
}
func (s HoldsVerOnePtrList) Mylist() VerOnePtr_List     { return VerOnePtr_List(C.Struct(s).GetObject(0)) }
func (s HoldsVerOnePtrList) SetMylist(v VerOnePtr_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type HoldsVerOnePtrList_List C.PointerList

func NewHoldsVerOnePtrListList(s *C.Segment, sz int) HoldsVerOnePtrList_List {
	return HoldsVerOnePtrList_List(s.NewCompositeList(0, 1, sz))
}
func (s HoldsVerOnePtrList_List) Len() int { return C.PointerList(s).Len() }
func (s HoldsVerOnePtrList_List) At(i int) HoldsVerOnePtrList {
	return HoldsVerOnePtrList(C.PointerList(s).At(i).ToStruct())
}
func (s HoldsVerOnePtrList_List) ToArray() []HoldsVerOnePtrList {
	n := s.Len()
	a := make([]HoldsVerOnePtrList, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsVerOnePtrList_List) Set(i int, item HoldsVerOnePtrList) {
	C.PointerList(s).Set(i, C.Object(item))
}

type HoldsVerOnePtrList_Struct struct {
	Mylist []*VerOnePtr_Struct
}

func (s HoldsVerOnePtrList) Struct() *HoldsVerOnePtrList_Struct {
	t := &HoldsVerOnePtrList_Struct{}
	for i := 0; i < s.Mylist().Len(); i++ {
		elem := s.Mylist().At(i).Struct()
		t.Mylist = append(t.Mylist, elem)
	}
	return t
}
func (s HoldsVerOnePtrList) LoadStruct(t *HoldsVerOnePtrList_Struct) {
	if t == nil {
		return
	}
	s.SetMylist(NewVerOnePtrList(s.Segment, len(t.Mylist)))
	for i := 0; i < len(t.Mylist); i++ {
		s.Mylist().Set(i, t.Mylist[i].Capnp(s.Segment))
	}
}
func (s *HoldsVerOnePtrList_Struct) Copy() *HoldsVerOnePtrList_Struct {
	t := &HoldsVerOnePtrList_Struct{}
	for _, e := range s.Mylist {
		if e != nil {
			t.Mylist = append(t.Mylist, e.Copy())
		} else {
			t.Mylist = append(t.Mylist, nil)
		}
	}
	return t
}
func (s *HoldsVerOnePtrList_Struct) Capnp(seg *C.Segment) HoldsVerOnePtrList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsVerOnePtrList(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsVerOnePtrList_Struct) RootCapnp(seg *C.Segment) HoldsVerOnePtrList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsVerOnePtrList(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsVerOnePtrList) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mylist\":")
		if err != nil {
			return err
		}
		{
			s := s.Mylist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerOnePtrList) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsVerOnePtrList) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mylist = ")
	if err != nil {
		return err
	}
	{
		s := s.Mylist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerOnePtrList) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsVerOnePtrListFromCapLit(s *C.Segment, b []byte) (p HoldsVerOnePtrList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsVerOnePtrList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsVerOnePtrListFromCapLit(s *C.Segment, b []byte) (p HoldsVerOnePtrList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsVerOnePtrList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsVerOnePtrList) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mylist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewVerOnePtrList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewVerOnePtr(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetMylist(t)
	}
	return err
}
func (s HoldsVerOnePtrList_List) FilterIndex(f func(i int, x HoldsVerOnePtrList) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsVerOnePtrList_List) Each(f func(i int, x HoldsVerOnePtrList) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsVerOnePtrList_List) Find(f func(i int, x HoldsVerOnePtrList) bool) (HoldsVerOnePtrList, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsVerOnePtrList{}, false
}
func (s HoldsVerOnePtrList) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsVerOnePtrList) LitName() string {
	return "HoldsVerOnePtrList"
}

type HoldsVerTwoPtrList C.Struct

func NewHoldsVerTwoPtrList(s *C.Segment) HoldsVerTwoPtrList {
	return HoldsVerTwoPtrList(s.NewStruct(0, 1))
}
func NewRootHoldsVerTwoPtrList(s *C.Segment) HoldsVerTwoPtrList {
	return HoldsVerTwoPtrList(s.NewRootStruct(0, 1))
}
func AutoNewHoldsVerTwoPtrList(s *C.Segment) HoldsVerTwoPtrList {
	return HoldsVerTwoPtrList(s.NewStructAR(0, 1))
}
func ReadRootHoldsVerTwoPtrList(s *C.Segment) HoldsVerTwoPtrList {
	return HoldsVerTwoPtrList(s.Root(0).ToStruct())
}
func (s HoldsVerTwoPtrList) Mylist() VerTwoPtr_List     { return VerTwoPtr_List(C.Struct(s).GetObject(0)) }
func (s HoldsVerTwoPtrList) SetMylist(v VerTwoPtr_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type HoldsVerTwoPtrList_List C.PointerList

func NewHoldsVerTwoPtrListList(s *C.Segment, sz int) HoldsVerTwoPtrList_List {
	return HoldsVerTwoPtrList_List(s.NewCompositeList(0, 1, sz))
}
func (s HoldsVerTwoPtrList_List) Len() int { return C.PointerList(s).Len() }
func (s HoldsVerTwoPtrList_List) At(i int) HoldsVerTwoPtrList {
	return HoldsVerTwoPtrList(C.PointerList(s).At(i).ToStruct())
}
func (s HoldsVerTwoPtrList_List) ToArray() []HoldsVerTwoPtrList {
	n := s.Len()
	a := make([]HoldsVerTwoPtrList, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsVerTwoPtrList_List) Set(i int, item HoldsVerTwoPtrList) {
	C.PointerList(s).Set(i, C.Object(item))
}

type HoldsVerTwoPtrList_Struct struct {
	Mylist []*VerTwoPtr_Struct
}

func (s HoldsVerTwoPtrList) Struct() *HoldsVerTwoPtrList_Struct {
	t := &HoldsVerTwoPtrList_Struct{}
	for i := 0; i < s.Mylist().Len(); i++ {
		elem := s.Mylist().At(i).Struct()
		t.Mylist = append(t.Mylist, elem)
	}
	return t
}
func (s HoldsVerTwoPtrList) LoadStruct(t *HoldsVerTwoPtrList_Struct) {
	if t == nil {
		return
	}
	s.SetMylist(NewVerTwoPtrList(s.Segment, len(t.Mylist)))
	for i := 0; i < len(t.Mylist); i++ {
		s.Mylist().Set(i, t.Mylist[i].Capnp(s.Segment))
	}
}
func (s *HoldsVerTwoPtrList_Struct) Copy() *HoldsVerTwoPtrList_Struct {
	t := &HoldsVerTwoPtrList_Struct{}
	for _, e := range s.Mylist {
		if e != nil {
			t.Mylist = append(t.Mylist, e.Copy())
		} else {
			t.Mylist = append(t.Mylist, nil)
		}
	}
	return t
}
func (s *HoldsVerTwoPtrList_Struct) Capnp(seg *C.Segment) HoldsVerTwoPtrList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsVerTwoPtrList(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsVerTwoPtrList_Struct) RootCapnp(seg *C.Segment) HoldsVerTwoPtrList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsVerTwoPtrList(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsVerTwoPtrList) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mylist\":")
		if err != nil {
			return err
		}
		{
			s := s.Mylist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoPtrList) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsVerTwoPtrList) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mylist = ")
	if err != nil {
		return err
	}
	{
		s := s.Mylist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoPtrList) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsVerTwoPtrListFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoPtrList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsVerTwoPtrList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsVerTwoPtrListFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoPtrList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsVerTwoPtrList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsVerTwoPtrList) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mylist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewVerTwoPtrList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewVerTwoPtr(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetMylist(t)
	}
	return err
}
func (s HoldsVerTwoPtrList_List) FilterIndex(f func(i int, x HoldsVerTwoPtrList) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsVerTwoPtrList_List) Each(f func(i int, x HoldsVerTwoPtrList) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsVerTwoPtrList_List) Find(f func(i int, x HoldsVerTwoPtrList) bool) (HoldsVerTwoPtrList, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsVerTwoPtrList{}, false
}
func (s HoldsVerTwoPtrList) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsVerTwoPtrList) LitName() string {
	return "HoldsVerTwoPtrList"
}

type HoldsVerTwoTwoList C.Struct

func NewHoldsVerTwoTwoList(s *C.Segment) HoldsVerTwoTwoList {
	return HoldsVerTwoTwoList(s.NewStruct(0, 1))
}
func NewRootHoldsVerTwoTwoList(s *C.Segment) HoldsVerTwoTwoList {
	return HoldsVerTwoTwoList(s.NewRootStruct(0, 1))
}
func AutoNewHoldsVerTwoTwoList(s *C.Segment) HoldsVerTwoTwoList {
	return HoldsVerTwoTwoList(s.NewStructAR(0, 1))
}
func ReadRootHoldsVerTwoTwoList(s *C.Segment) HoldsVerTwoTwoList {
	return HoldsVerTwoTwoList(s.Root(0).ToStruct())
}
func (s HoldsVerTwoTwoList) Mylist() VerTwoDataTwoPtr_List {
	return VerTwoDataTwoPtr_List(C.Struct(s).GetObject(0))
}
func (s HoldsVerTwoTwoList) SetMylist(v VerTwoDataTwoPtr_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type HoldsVerTwoTwoList_List C.PointerList

func NewHoldsVerTwoTwoListList(s *C.Segment, sz int) HoldsVerTwoTwoList_List {
	return HoldsVerTwoTwoList_List(s.NewCompositeList(0, 1, sz))
}
func (s HoldsVerTwoTwoList_List) Len() int { return C.PointerList(s).Len() }
func (s HoldsVerTwoTwoList_List) At(i int) HoldsVerTwoTwoList {
	return HoldsVerTwoTwoList(C.PointerList(s).At(i).ToStruct())
}
func (s HoldsVerTwoTwoList_List) ToArray() []HoldsVerTwoTwoList {
	n := s.Len()
	a := make([]HoldsVerTwoTwoList, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsVerTwoTwoList_List) Set(i int, item HoldsVerTwoTwoList) {
	C.PointerList(s).Set(i, C.Object(item))
}

type HoldsVerTwoTwoList_Struct struct {
	Mylist []*VerTwoDataTwoPtr_Struct
}

func (s HoldsVerTwoTwoList) Struct() *HoldsVerTwoTwoList_Struct {
	t := &HoldsVerTwoTwoList_Struct{}
	for i := 0; i < s.Mylist().Len(); i++ {
		elem := s.Mylist().At(i).Struct()
		t.Mylist = append(t.Mylist, elem)
	}
	return t
}
func (s HoldsVerTwoTwoList) LoadStruct(t *HoldsVerTwoTwoList_Struct) {
	if t == nil {
		return
	}
	s.SetMylist(NewVerTwoDataTwoPtrList(s.Segment, len(t.Mylist)))
	for i := 0; i < len(t.Mylist); i++ {
		s.Mylist().Set(i, t.Mylist[i].Capnp(s.Segment))
	}
}
func (s *HoldsVerTwoTwoList_Struct) Copy() *HoldsVerTwoTwoList_Struct {
	t := &HoldsVerTwoTwoList_Struct{}
	for _, e := range s.Mylist {
		if e != nil {
			t.Mylist = append(t.Mylist, e.Copy())
		} else {
			t.Mylist = append(t.Mylist, nil)
		}
	}
	return t
}
func (s *HoldsVerTwoTwoList_Struct) Capnp(seg *C.Segment) HoldsVerTwoTwoList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsVerTwoTwoList(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsVerTwoTwoList_Struct) RootCapnp(seg *C.Segment) HoldsVerTwoTwoList {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsVerTwoTwoList(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsVerTwoTwoList) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mylist\":")
		if err != nil {
			return err
		}
		{
			s := s.Mylist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoTwoList) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsVerTwoTwoList) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mylist = ")
	if err != nil {
		return err
	}
	{
		s := s.Mylist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoTwoList) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsVerTwoTwoListFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoTwoList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsVerTwoTwoList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsVerTwoTwoListFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoTwoList, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsVerTwoTwoList(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsVerTwoTwoList) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mylist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewVerTwoDataTwoPtrList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewVerTwoDataTwoPtr(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetMylist(t)
	}
	return err
}
func (s HoldsVerTwoTwoList_List) FilterIndex(f func(i int, x HoldsVerTwoTwoList) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsVerTwoTwoList_List) Each(f func(i int, x HoldsVerTwoTwoList) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsVerTwoTwoList_List) Find(f func(i int, x HoldsVerTwoTwoList) bool) (HoldsVerTwoTwoList, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsVerTwoTwoList{}, false
}
func (s HoldsVerTwoTwoList) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsVerTwoTwoList) LitName() string {
	return "HoldsVerTwoTwoList"
}

type HoldsVerTwoTwoPlus C.Struct

func NewHoldsVerTwoTwoPlus(s *C.Segment) HoldsVerTwoTwoPlus {
	return HoldsVerTwoTwoPlus(s.NewStruct(0, 1))
}
func NewRootHoldsVerTwoTwoPlus(s *C.Segment) HoldsVerTwoTwoPlus {
	return HoldsVerTwoTwoPlus(s.NewRootStruct(0, 1))
}
func AutoNewHoldsVerTwoTwoPlus(s *C.Segment) HoldsVerTwoTwoPlus {
	return HoldsVerTwoTwoPlus(s.NewStructAR(0, 1))
}
func ReadRootHoldsVerTwoTwoPlus(s *C.Segment) HoldsVerTwoTwoPlus {
	return HoldsVerTwoTwoPlus(s.Root(0).ToStruct())
}
func (s HoldsVerTwoTwoPlus) Mylist() VerTwoTwoPlus_List {
	return VerTwoTwoPlus_List(C.Struct(s).GetObject(0))
}
func (s HoldsVerTwoTwoPlus) SetMylist(v VerTwoTwoPlus_List) { C.Struct(s).SetObject(0, C.Object(v)) }

type HoldsVerTwoTwoPlus_List C.PointerList

func NewHoldsVerTwoTwoPlusList(s *C.Segment, sz int) HoldsVerTwoTwoPlus_List {
	return HoldsVerTwoTwoPlus_List(s.NewCompositeList(0, 1, sz))
}
func (s HoldsVerTwoTwoPlus_List) Len() int { return C.PointerList(s).Len() }
func (s HoldsVerTwoTwoPlus_List) At(i int) HoldsVerTwoTwoPlus {
	return HoldsVerTwoTwoPlus(C.PointerList(s).At(i).ToStruct())
}
func (s HoldsVerTwoTwoPlus_List) ToArray() []HoldsVerTwoTwoPlus {
	n := s.Len()
	a := make([]HoldsVerTwoTwoPlus, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsVerTwoTwoPlus_List) Set(i int, item HoldsVerTwoTwoPlus) {
	C.PointerList(s).Set(i, C.Object(item))
}

type HoldsVerTwoTwoPlus_Struct struct {
	Mylist []*VerTwoTwoPlus_Struct
}

func (s HoldsVerTwoTwoPlus) Struct() *HoldsVerTwoTwoPlus_Struct {
	t := &HoldsVerTwoTwoPlus_Struct{}
	for i := 0; i < s.Mylist().Len(); i++ {
		elem := s.Mylist().At(i).Struct()
		t.Mylist = append(t.Mylist, elem)
	}
	return t
}
func (s HoldsVerTwoTwoPlus) LoadStruct(t *HoldsVerTwoTwoPlus_Struct) {
	if t == nil {
		return
	}
	s.SetMylist(NewVerTwoTwoPlusList(s.Segment, len(t.Mylist)))
	for i := 0; i < len(t.Mylist); i++ {
		s.Mylist().Set(i, t.Mylist[i].Capnp(s.Segment))
	}
}
func (s *HoldsVerTwoTwoPlus_Struct) Copy() *HoldsVerTwoTwoPlus_Struct {
	t := &HoldsVerTwoTwoPlus_Struct{}
	for _, e := range s.Mylist {
		if e != nil {
			t.Mylist = append(t.Mylist, e.Copy())
		} else {
			t.Mylist = append(t.Mylist, nil)
		}
	}
	return t
}
func (s *HoldsVerTwoTwoPlus_Struct) Capnp(seg *C.Segment) HoldsVerTwoTwoPlus {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsVerTwoTwoPlus(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsVerTwoTwoPlus_Struct) RootCapnp(seg *C.Segment) HoldsVerTwoTwoPlus {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsVerTwoTwoPlus(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsVerTwoTwoPlus) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mylist\":")
		if err != nil {
			return err
		}
		{
			s := s.Mylist()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoTwoPlus) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsVerTwoTwoPlus) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mylist = ")
	if err != nil {
		return err
	}
	{
		s := s.Mylist()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsVerTwoTwoPlus) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsVerTwoTwoPlusFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoTwoPlus, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsVerTwoTwoPlus(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsVerTwoTwoPlusFromCapLit(s *C.Segment, b []byte) (p HoldsVerTwoTwoPlus, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsVerTwoTwoPlus(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsVerTwoTwoPlus) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mylist"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewVerTwoTwoPlusList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewVerTwoTwoPlus(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetMylist(t)
	}
	return err
}
func (s HoldsVerTwoTwoPlus_List) FilterIndex(f func(i int, x HoldsVerTwoTwoPlus) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsVerTwoTwoPlus_List) Each(f func(i int, x HoldsVerTwoTwoPlus) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsVerTwoTwoPlus_List) Find(f func(i int, x HoldsVerTwoTwoPlus) bool) (HoldsVerTwoTwoPlus, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsVerTwoTwoPlus{}, false
}
func (s HoldsVerTwoTwoPlus) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsVerTwoTwoPlus) LitName() string {
	return "HoldsVerTwoTwoPlus"
}

type VerTwoTwoPlus C.Struct

func NewVerTwoTwoPlus(s *C.Segment) VerTwoTwoPlus      { return VerTwoTwoPlus(s.NewStruct(24, 3)) }
func NewRootVerTwoTwoPlus(s *C.Segment) VerTwoTwoPlus  { return VerTwoTwoPlus(s.NewRootStruct(24, 3)) }
func AutoNewVerTwoTwoPlus(s *C.Segment) VerTwoTwoPlus  { return VerTwoTwoPlus(s.NewStructAR(24, 3)) }
func ReadRootVerTwoTwoPlus(s *C.Segment) VerTwoTwoPlus { return VerTwoTwoPlus(s.Root(0).ToStruct()) }
func (s VerTwoTwoPlus) Val() int16                     { return int16(C.Struct(s).Get16(0)) }
func (s VerTwoTwoPlus) SetVal(v int16)                 { C.Struct(s).Set16(0, uint16(v)) }
func (s VerTwoTwoPlus) Duo() int64                     { return int64(C.Struct(s).Get64(8)) }
func (s VerTwoTwoPlus) SetDuo(v int64)                 { C.Struct(s).Set64(8, uint64(v)) }
func (s VerTwoTwoPlus) Ptr1() VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(C.Struct(s).GetObject(0).ToStruct())
}
func (s VerTwoTwoPlus) SetPtr1(v VerTwoDataTwoPtr) { C.Struct(s).SetObject(0, C.Object(v)) }
func (s VerTwoTwoPlus) Ptr2() VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(C.Struct(s).GetObject(1).ToStruct())
}
func (s VerTwoTwoPlus) SetPtr2(v VerTwoDataTwoPtr) { C.Struct(s).SetObject(1, C.Object(v)) }
func (s VerTwoTwoPlus) Tre() int64                 { return int64(C.Struct(s).Get64(16)) }
func (s VerTwoTwoPlus) SetTre(v int64)             { C.Struct(s).Set64(16, uint64(v)) }
func (s VerTwoTwoPlus) Lst3() C.Int64List          { return C.Int64List(C.Struct(s).GetObject(2)) }
func (s VerTwoTwoPlus) SetLst3(v C.Int64List)      { C.Struct(s).SetObject(2, C.Object(v)) }

type VerTwoTwoPlus_List C.PointerList

func NewVerTwoTwoPlusList(s *C.Segment, sz int) VerTwoTwoPlus_List {
	return VerTwoTwoPlus_List(s.NewCompositeList(24, 3, sz))
}
func (s VerTwoTwoPlus_List) Len() int { return C.PointerList(s).Len() }
func (s VerTwoTwoPlus_List) At(i int) VerTwoTwoPlus {
	return VerTwoTwoPlus(C.PointerList(s).At(i).ToStruct())
}
func (s VerTwoTwoPlus_List) ToArray() []VerTwoTwoPlus {
	n := s.Len()
	a := make([]VerTwoTwoPlus, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VerTwoTwoPlus_List) Set(i int, item VerTwoTwoPlus) { C.PointerList(s).Set(i, C.Object(item)) }

type VerTwoTwoPlus_Struct struct {
	Val  int16
	Duo  int64
	Ptr1 *VerTwoDataTwoPtr_Struct
	Ptr2 *VerTwoDataTwoPtr_Struct
	Tre  int64
	Lst3 []int64
}

func (s VerTwoTwoPlus) Struct() *VerTwoTwoPlus_Struct {
	t := &VerTwoTwoPlus_Struct{}
	t.Val = s.Val()
	t.Duo = s.Duo()
	{
		t.Ptr1 = s.Ptr1().Struct()
	}
	{
		t.Ptr2 = s.Ptr2().Struct()
	}
	t.Tre = s.Tre()
	for i := 0; i < s.Lst3().Len(); i++ {
		t.Lst3 = append(t.Lst3, s.Lst3().At(i))
	}
	return t
}
func (s VerTwoTwoPlus) LoadStruct(t *VerTwoTwoPlus_Struct) {
	if t == nil {
		return
	}
	s.SetVal(t.Val)
	s.SetDuo(t.Duo)
	{
		p := NewVerTwoDataTwoPtr(s.Segment)
		p.LoadStruct(t.Ptr1)
		s.SetPtr1(p)
	}
	{
		p := NewVerTwoDataTwoPtr(s.Segment)
		p.LoadStruct(t.Ptr2)
		s.SetPtr2(p)
	}
	s.SetTre(t.Tre)
	s.SetLst3(s.Segment.NewInt64List(len(t.Lst3)))
	for i := 0; i < len(t.Lst3); i++ {
		s.Lst3().Set(i, t.Lst3[i])
	}
}
func (s *VerTwoTwoPlus_Struct) Copy() *VerTwoTwoPlus_Struct {
	t := &VerTwoTwoPlus_Struct{}
	t.Val = s.Val
	t.Duo = s.Duo
	if s.Ptr1 != nil {
		t.Ptr1 = s.Ptr1.Copy()
	}
	if s.Ptr2 != nil {
		t.Ptr2 = s.Ptr2.Copy()
	}
	t.Tre = s.Tre
	for _, e := range s.Lst3 {
		t.Lst3 = append(t.Lst3, e)
	}
	return t
}
func (s *VerTwoTwoPlus_Struct) Capnp(seg *C.Segment) VerTwoTwoPlus {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVerTwoTwoPlus(seg)
	t.LoadStruct(s)
	return t
}
func (s *VerTwoTwoPlus_Struct) RootCapnp(seg *C.Segment) VerTwoTwoPlus {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVerTwoTwoPlus(seg)
	t.LoadStruct(s)
	return t
}
func (s VerTwoTwoPlus) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"val\":")
		if err != nil {
			return err
		}
		{
			s := s.Val()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"duo\":")
		if err != nil {
			return err
		}
		{
			s := s.Duo()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ptr1\":")
		if err != nil {
			return err
		}
		{
			s := s.Ptr1()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ptr2\":")
		if err != nil {
			return err
		}
		{
			s := s.Ptr2()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"tre\":")
		if err != nil {
			return err
		}
		{
			s := s.Tre()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"lst3\":")
		if err != nil {
			return err
		}
		{
			s := s.Lst3()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoTwoPlus) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VerTwoTwoPlus) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("val = ")
	if err != nil {
		return err
	}
	{
		s := s.Val()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("duo = ")
	if err != nil {
		return err
	}
	{
		s := s.Duo()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("ptr1 = ")
	if err != nil {
		return err
	}
	{
		s := s.Ptr1()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("ptr2 = ")
	if err != nil {
		return err
	}
	{
		s := s.Ptr2()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("tre = ")
	if err != nil {
		return err
	}
	{
		s := s.Tre()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("lst3 = ")
	if err != nil {
		return err
	}
	{
		s := s.Lst3()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VerTwoTwoPlus) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVerTwoTwoPlusFromCapLit(s *C.Segment, b []byte) (p VerTwoTwoPlus, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVerTwoTwoPlus(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVerTwoTwoPlusFromCapLit(s *C.Segment, b []byte) (p VerTwoTwoPlus, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVerTwoTwoPlus(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VerTwoTwoPlus) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["val"]; ok {
		_ = fn
		var t int16
		if temp, ok := fn.Val.(int64); ok {
			t = int16(temp)
		} else {
			return fmt.Errorf("expected 'int16' but didn't matched")
		}
		_ = t
		s.SetVal(t)
	}
	if fn, ok := sv["duo"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetDuo(t)
	}
	if fn, ok := sv["ptr1"]; ok {
		_ = fn
		t := NewVerTwoDataTwoPtr(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPtr1(t)
	}
	if fn, ok := sv["ptr2"]; ok {
		_ = fn
		t := NewVerTwoDataTwoPtr(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetPtr2(t)
	}
	if fn, ok := sv["tre"]; ok {
		_ = fn
		var t int64
		if temp, ok := fn.Val.(int64); ok {
			t = int64(temp)
		} else {
			return fmt.Errorf("expected 'int64' but didn't matched")
		}
		_ = t
		s.SetTre(t)
	}
	if fn, ok := sv["lst3"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewInt64List(len(lv))
		for i, en := range lv {
			_ = en
			var ev int64
			if temp, ok := en.Val.(int64); ok {
				ev = int64(temp)
			} else {
				return fmt.Errorf("expected 'int64' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetLst3(t)
	}
	return err
}
func (s VerTwoTwoPlus_List) FilterIndex(f func(i int, x VerTwoTwoPlus) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VerTwoTwoPlus_List) Each(f func(i int, x VerTwoTwoPlus) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VerTwoTwoPlus_List) Find(f func(i int, x VerTwoTwoPlus) bool) (VerTwoTwoPlus, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VerTwoTwoPlus{}, false
}
func (s VerTwoTwoPlus) Seg() *C.Segment {
	return s.Segment
}
func (s VerTwoTwoPlus) LitName() string {
	return "VerTwoTwoPlus"
}

type HoldsText C.Struct

func NewHoldsText(s *C.Segment) HoldsText      { return HoldsText(s.NewStruct(0, 3)) }
func NewRootHoldsText(s *C.Segment) HoldsText  { return HoldsText(s.NewRootStruct(0, 3)) }
func AutoNewHoldsText(s *C.Segment) HoldsText  { return HoldsText(s.NewStructAR(0, 3)) }
func ReadRootHoldsText(s *C.Segment) HoldsText { return HoldsText(s.Root(0).ToStruct()) }
func (s HoldsText) Txt() string                { return C.Struct(s).GetObject(0).ToText() }
func (s HoldsText) TxtBytes() []byte           { return C.Struct(s).GetObject(0).ToDataTrimLastByte() }
func (s HoldsText) SetTxt(v string)            { C.Struct(s).SetObject(0, s.Segment.NewText(v)) }
func (s HoldsText) Lst() C.TextList            { return C.TextList(C.Struct(s).GetObject(1)) }
func (s HoldsText) SetLst(v C.TextList)        { C.Struct(s).SetObject(1, C.Object(v)) }
func (s HoldsText) Lstlst() C.PointerList      { return C.PointerList(C.Struct(s).GetObject(2)) }
func (s HoldsText) SetLstlst(v C.PointerList)  { C.Struct(s).SetObject(2, C.Object(v)) }

type HoldsText_List C.PointerList

func NewHoldsTextList(s *C.Segment, sz int) HoldsText_List {
	return HoldsText_List(s.NewCompositeList(0, 3, sz))
}
func (s HoldsText_List) Len() int           { return C.PointerList(s).Len() }
func (s HoldsText_List) At(i int) HoldsText { return HoldsText(C.PointerList(s).At(i).ToStruct()) }
func (s HoldsText_List) ToArray() []HoldsText {
	n := s.Len()
	a := make([]HoldsText, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s HoldsText_List) Set(i int, item HoldsText) { C.PointerList(s).Set(i, C.Object(item)) }

type HoldsText_Struct struct {
	Txt    string
	Lst    []string
	Lstlst [][]string
}

func (s HoldsText) Struct() *HoldsText_Struct {
	t := &HoldsText_Struct{}
	t.Txt = s.Txt()
	for i := 0; i < s.Lst().Len(); i++ {
		t.Lst = append(t.Lst, s.Lst().At(i))
	}
	for i := 0; i < s.Lstlst().Len(); i++ {
		t.Lstlst = nil
		panic("List of List not supported now")
	}
	return t
}
func (s HoldsText) LoadStruct(t *HoldsText_Struct) {
	if t == nil {
		return
	}
	s.SetTxt(t.Txt)
	s.SetLst(s.Segment.NewTextList(len(t.Lst)))
	for i := 0; i < len(t.Lst); i++ {
		s.Lst().Set(i, t.Lst[i])
	}
	s.SetLstlst(s.Segment.NewPointerList(len(t.Lstlst)))
	for i := 0; i < len(t.Lstlst); i++ {
		panic("List of List not supported now")
	}
}
func (s *HoldsText_Struct) Copy() *HoldsText_Struct {
	t := &HoldsText_Struct{}
	t.Txt = s.Txt
	for _, e := range s.Lst {
		t.Lst = append(t.Lst, e)
	}
	for _, e := range s.Lstlst {
		t.Lstlst = append(t.Lstlst, e)
	}
	return t
}
func (s *HoldsText_Struct) Capnp(seg *C.Segment) HoldsText {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewHoldsText(seg)
	t.LoadStruct(s)
	return t
}
func (s *HoldsText_Struct) RootCapnp(seg *C.Segment) HoldsText {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootHoldsText(seg)
	t.LoadStruct(s)
	return t
}
func (s HoldsText) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"txt\":")
		if err != nil {
			return err
		}
		{
			s := s.Txt()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"lst\":")
		if err != nil {
			return err
		}
		{
			s := s.Lst()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"lstlst\":")
		if err != nil {
			return err
		}
		{
			s := s.Lstlst()
			_ = s
			_, err = b.WriteString("\"untyped list\"")
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsText) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s HoldsText) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("txt = ")
	if err != nil {
		return err
	}
	{
		s := s.Txt()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("lst = ")
	if err != nil {
		return err
	}
	{
		s := s.Lst()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("lstlst = ")
	if err != nil {
		return err
	}
	{
		s := s.Lstlst()
		_ = s
		_, err = b.WriteString("\"untyped list\"")
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s HoldsText) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewHoldsTextFromCapLit(s *C.Segment, b []byte) (p HoldsText, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewHoldsText(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootHoldsTextFromCapLit(s *C.Segment, b []byte) (p HoldsText, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootHoldsText(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s HoldsText) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["txt"]; ok {
		_ = fn
		t, ok := fn.Val.(string)
		if !ok {
			return fmt.Errorf("expected 'string' but didn't matched")
		}
		_ = t
		s.SetTxt(t)
	}
	if fn, ok := sv["lst"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewTextList(len(lv))
		for i, en := range lv {
			_ = en
			ev, ok := en.Val.(string)
			if !ok {
				return fmt.Errorf("expected 'string' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetLst(t)
	}
	if fn, ok := sv["lstlst"]; ok {
		_ = fn
		t := C.PointerList{}
		panic("in HoldsText, list of list' or 'list of pointer' is not supported")
		s.SetLstlst(t)
	}
	return err
}
func (s HoldsText_List) FilterIndex(f func(i int, x HoldsText) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s HoldsText_List) Each(f func(i int, x HoldsText) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s HoldsText_List) Find(f func(i int, x HoldsText) bool) (HoldsText, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return HoldsText{}, false
}
func (s HoldsText) Seg() *C.Segment {
	return s.Segment
}
func (s HoldsText) LitName() string {
	return "HoldsText"
}

type WrapEmpty C.Struct

func NewWrapEmpty(s *C.Segment) WrapEmpty      { return WrapEmpty(s.NewStruct(0, 1)) }
func NewRootWrapEmpty(s *C.Segment) WrapEmpty  { return WrapEmpty(s.NewRootStruct(0, 1)) }
func AutoNewWrapEmpty(s *C.Segment) WrapEmpty  { return WrapEmpty(s.NewStructAR(0, 1)) }
func ReadRootWrapEmpty(s *C.Segment) WrapEmpty { return WrapEmpty(s.Root(0).ToStruct()) }
func (s WrapEmpty) MightNotBeReallyEmpty() VerEmpty {
	return VerEmpty(C.Struct(s).GetObject(0).ToStruct())
}
func (s WrapEmpty) SetMightNotBeReallyEmpty(v VerEmpty) { C.Struct(s).SetObject(0, C.Object(v)) }

type WrapEmpty_List C.PointerList

func NewWrapEmptyList(s *C.Segment, sz int) WrapEmpty_List {
	return WrapEmpty_List(s.NewCompositeList(0, 1, sz))
}
func (s WrapEmpty_List) Len() int           { return C.PointerList(s).Len() }
func (s WrapEmpty_List) At(i int) WrapEmpty { return WrapEmpty(C.PointerList(s).At(i).ToStruct()) }
func (s WrapEmpty_List) ToArray() []WrapEmpty {
	n := s.Len()
	a := make([]WrapEmpty, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s WrapEmpty_List) Set(i int, item WrapEmpty) { C.PointerList(s).Set(i, C.Object(item)) }

type WrapEmpty_Struct struct {
	MightNotBeReallyEmpty *VerEmpty_Struct
}

func (s WrapEmpty) Struct() *WrapEmpty_Struct {
	t := &WrapEmpty_Struct{}
	{
		t.MightNotBeReallyEmpty = s.MightNotBeReallyEmpty().Struct()
	}
	return t
}
func (s WrapEmpty) LoadStruct(t *WrapEmpty_Struct) {
	if t == nil {
		return
	}
	{
		p := NewVerEmpty(s.Segment)
		p.LoadStruct(t.MightNotBeReallyEmpty)
		s.SetMightNotBeReallyEmpty(p)
	}
}
func (s *WrapEmpty_Struct) Copy() *WrapEmpty_Struct {
	t := &WrapEmpty_Struct{}
	if s.MightNotBeReallyEmpty != nil {
		t.MightNotBeReallyEmpty = s.MightNotBeReallyEmpty.Copy()
	}
	return t
}
func (s *WrapEmpty_Struct) Capnp(seg *C.Segment) WrapEmpty {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewWrapEmpty(seg)
	t.LoadStruct(s)
	return t
}
func (s *WrapEmpty_Struct) RootCapnp(seg *C.Segment) WrapEmpty {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootWrapEmpty(seg)
	t.LoadStruct(s)
	return t
}
func (s WrapEmpty) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mightNotBeReallyEmpty\":")
		if err != nil {
			return err
		}
		{
			s := s.MightNotBeReallyEmpty()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s WrapEmpty) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s WrapEmpty) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mightNotBeReallyEmpty = ")
	if err != nil {
		return err
	}
	{
		s := s.MightNotBeReallyEmpty()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s WrapEmpty) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewWrapEmptyFromCapLit(s *C.Segment, b []byte) (p WrapEmpty, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewWrapEmpty(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootWrapEmptyFromCapLit(s *C.Segment, b []byte) (p WrapEmpty, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootWrapEmpty(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s WrapEmpty) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mightNotBeReallyEmpty"]; ok {
		_ = fn
		t := NewVerEmpty(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetMightNotBeReallyEmpty(t)
	}
	return err
}
func (s WrapEmpty_List) FilterIndex(f func(i int, x WrapEmpty) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s WrapEmpty_List) Each(f func(i int, x WrapEmpty) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s WrapEmpty_List) Find(f func(i int, x WrapEmpty) bool) (WrapEmpty, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return WrapEmpty{}, false
}
func (s WrapEmpty) Seg() *C.Segment {
	return s.Segment
}
func (s WrapEmpty) LitName() string {
	return "WrapEmpty"
}

type Wrap2x2 C.Struct

func NewWrap2x2(s *C.Segment) Wrap2x2      { return Wrap2x2(s.NewStruct(0, 1)) }
func NewRootWrap2x2(s *C.Segment) Wrap2x2  { return Wrap2x2(s.NewRootStruct(0, 1)) }
func AutoNewWrap2x2(s *C.Segment) Wrap2x2  { return Wrap2x2(s.NewStructAR(0, 1)) }
func ReadRootWrap2x2(s *C.Segment) Wrap2x2 { return Wrap2x2(s.Root(0).ToStruct()) }
func (s Wrap2x2) MightNotBeReallyEmpty() VerTwoDataTwoPtr {
	return VerTwoDataTwoPtr(C.Struct(s).GetObject(0).ToStruct())
}
func (s Wrap2x2) SetMightNotBeReallyEmpty(v VerTwoDataTwoPtr) { C.Struct(s).SetObject(0, C.Object(v)) }

type Wrap2x2_List C.PointerList

func NewWrap2x2List(s *C.Segment, sz int) Wrap2x2_List {
	return Wrap2x2_List(s.NewCompositeList(0, 1, sz))
}
func (s Wrap2x2_List) Len() int         { return C.PointerList(s).Len() }
func (s Wrap2x2_List) At(i int) Wrap2x2 { return Wrap2x2(C.PointerList(s).At(i).ToStruct()) }
func (s Wrap2x2_List) ToArray() []Wrap2x2 {
	n := s.Len()
	a := make([]Wrap2x2, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Wrap2x2_List) Set(i int, item Wrap2x2) { C.PointerList(s).Set(i, C.Object(item)) }

type Wrap2x2_Struct struct {
	MightNotBeReallyEmpty *VerTwoDataTwoPtr_Struct
}

func (s Wrap2x2) Struct() *Wrap2x2_Struct {
	t := &Wrap2x2_Struct{}
	{
		t.MightNotBeReallyEmpty = s.MightNotBeReallyEmpty().Struct()
	}
	return t
}
func (s Wrap2x2) LoadStruct(t *Wrap2x2_Struct) {
	if t == nil {
		return
	}
	{
		p := NewVerTwoDataTwoPtr(s.Segment)
		p.LoadStruct(t.MightNotBeReallyEmpty)
		s.SetMightNotBeReallyEmpty(p)
	}
}
func (s *Wrap2x2_Struct) Copy() *Wrap2x2_Struct {
	t := &Wrap2x2_Struct{}
	if s.MightNotBeReallyEmpty != nil {
		t.MightNotBeReallyEmpty = s.MightNotBeReallyEmpty.Copy()
	}
	return t
}
func (s *Wrap2x2_Struct) Capnp(seg *C.Segment) Wrap2x2 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewWrap2x2(seg)
	t.LoadStruct(s)
	return t
}
func (s *Wrap2x2_Struct) RootCapnp(seg *C.Segment) Wrap2x2 {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootWrap2x2(seg)
	t.LoadStruct(s)
	return t
}
func (s Wrap2x2) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mightNotBeReallyEmpty\":")
		if err != nil {
			return err
		}
		{
			s := s.MightNotBeReallyEmpty()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Wrap2x2) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Wrap2x2) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mightNotBeReallyEmpty = ")
	if err != nil {
		return err
	}
	{
		s := s.MightNotBeReallyEmpty()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Wrap2x2) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewWrap2x2FromCapLit(s *C.Segment, b []byte) (p Wrap2x2, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewWrap2x2(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootWrap2x2FromCapLit(s *C.Segment, b []byte) (p Wrap2x2, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootWrap2x2(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Wrap2x2) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mightNotBeReallyEmpty"]; ok {
		_ = fn
		t := NewVerTwoDataTwoPtr(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetMightNotBeReallyEmpty(t)
	}
	return err
}
func (s Wrap2x2_List) FilterIndex(f func(i int, x Wrap2x2) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Wrap2x2_List) Each(f func(i int, x Wrap2x2) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Wrap2x2_List) Find(f func(i int, x Wrap2x2) bool) (Wrap2x2, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Wrap2x2{}, false
}
func (s Wrap2x2) Seg() *C.Segment {
	return s.Segment
}
func (s Wrap2x2) LitName() string {
	return "Wrap2x2"
}

type Wrap2x2plus C.Struct

func NewWrap2x2plus(s *C.Segment) Wrap2x2plus      { return Wrap2x2plus(s.NewStruct(0, 1)) }
func NewRootWrap2x2plus(s *C.Segment) Wrap2x2plus  { return Wrap2x2plus(s.NewRootStruct(0, 1)) }
func AutoNewWrap2x2plus(s *C.Segment) Wrap2x2plus  { return Wrap2x2plus(s.NewStructAR(0, 1)) }
func ReadRootWrap2x2plus(s *C.Segment) Wrap2x2plus { return Wrap2x2plus(s.Root(0).ToStruct()) }
func (s Wrap2x2plus) MightNotBeReallyEmpty() VerTwoTwoPlus {
	return VerTwoTwoPlus(C.Struct(s).GetObject(0).ToStruct())
}
func (s Wrap2x2plus) SetMightNotBeReallyEmpty(v VerTwoTwoPlus) { C.Struct(s).SetObject(0, C.Object(v)) }

type Wrap2x2plus_List C.PointerList

func NewWrap2x2plusList(s *C.Segment, sz int) Wrap2x2plus_List {
	return Wrap2x2plus_List(s.NewCompositeList(0, 1, sz))
}
func (s Wrap2x2plus_List) Len() int { return C.PointerList(s).Len() }
func (s Wrap2x2plus_List) At(i int) Wrap2x2plus {
	return Wrap2x2plus(C.PointerList(s).At(i).ToStruct())
}
func (s Wrap2x2plus_List) ToArray() []Wrap2x2plus {
	n := s.Len()
	a := make([]Wrap2x2plus, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Wrap2x2plus_List) Set(i int, item Wrap2x2plus) { C.PointerList(s).Set(i, C.Object(item)) }

type Wrap2x2plus_Struct struct {
	MightNotBeReallyEmpty *VerTwoTwoPlus_Struct
}

func (s Wrap2x2plus) Struct() *Wrap2x2plus_Struct {
	t := &Wrap2x2plus_Struct{}
	{
		t.MightNotBeReallyEmpty = s.MightNotBeReallyEmpty().Struct()
	}
	return t
}
func (s Wrap2x2plus) LoadStruct(t *Wrap2x2plus_Struct) {
	if t == nil {
		return
	}
	{
		p := NewVerTwoTwoPlus(s.Segment)
		p.LoadStruct(t.MightNotBeReallyEmpty)
		s.SetMightNotBeReallyEmpty(p)
	}
}
func (s *Wrap2x2plus_Struct) Copy() *Wrap2x2plus_Struct {
	t := &Wrap2x2plus_Struct{}
	if s.MightNotBeReallyEmpty != nil {
		t.MightNotBeReallyEmpty = s.MightNotBeReallyEmpty.Copy()
	}
	return t
}
func (s *Wrap2x2plus_Struct) Capnp(seg *C.Segment) Wrap2x2plus {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewWrap2x2plus(seg)
	t.LoadStruct(s)
	return t
}
func (s *Wrap2x2plus_Struct) RootCapnp(seg *C.Segment) Wrap2x2plus {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootWrap2x2plus(seg)
	t.LoadStruct(s)
	return t
}
func (s Wrap2x2plus) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"mightNotBeReallyEmpty\":")
		if err != nil {
			return err
		}
		{
			s := s.MightNotBeReallyEmpty()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Wrap2x2plus) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Wrap2x2plus) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("mightNotBeReallyEmpty = ")
	if err != nil {
		return err
	}
	{
		s := s.MightNotBeReallyEmpty()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Wrap2x2plus) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewWrap2x2plusFromCapLit(s *C.Segment, b []byte) (p Wrap2x2plus, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewWrap2x2plus(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootWrap2x2plusFromCapLit(s *C.Segment, b []byte) (p Wrap2x2plus, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootWrap2x2plus(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Wrap2x2plus) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["mightNotBeReallyEmpty"]; ok {
		_ = fn
		t := NewVerTwoTwoPlus(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetMightNotBeReallyEmpty(t)
	}
	return err
}
func (s Wrap2x2plus_List) FilterIndex(f func(i int, x Wrap2x2plus) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Wrap2x2plus_List) Each(f func(i int, x Wrap2x2plus) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Wrap2x2plus_List) Find(f func(i int, x Wrap2x2plus) bool) (Wrap2x2plus, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Wrap2x2plus{}, false
}
func (s Wrap2x2plus) Seg() *C.Segment {
	return s.Segment
}
func (s Wrap2x2plus) LitName() string {
	return "Wrap2x2plus"
}

type Endpoint C.Struct

func NewEndpoint(s *C.Segment) Endpoint      { return Endpoint(s.NewStruct(8, 2)) }
func NewRootEndpoint(s *C.Segment) Endpoint  { return Endpoint(s.NewRootStruct(8, 2)) }
func AutoNewEndpoint(s *C.Segment) Endpoint  { return Endpoint(s.NewStructAR(8, 2)) }
func ReadRootEndpoint(s *C.Segment) Endpoint { return Endpoint(s.Root(0).ToStruct()) }
func (s Endpoint) Ip() net.IP                { return net.IP(C.Struct(s).GetObject(0).ToData()) }
func (s Endpoint) SetIp(v net.IP)            { C.Struct(s).SetObject(0, s.Segment.NewData([]byte(v))) }
func (s Endpoint) Port() int16               { return int16(C.Struct(s).Get16(0)) }
func (s Endpoint) SetPort(v int16)           { C.Struct(s).Set16(0, uint16(v)) }
func (s Endpoint) Hostname() string          { return C.Struct(s).GetObject(1).ToText() }
func (s Endpoint) HostnameBytes() []byte     { return C.Struct(s).GetObject(1).ToDataTrimLastByte() }
func (s Endpoint) SetHostname(v string)      { C.Struct(s).SetObject(1, s.Segment.NewText(v)) }

type Endpoint_List C.PointerList

func NewEndpointList(s *C.Segment, sz int) Endpoint_List {
	return Endpoint_List(s.NewCompositeList(8, 2, sz))
}
func (s Endpoint_List) Len() int          { return C.PointerList(s).Len() }
func (s Endpoint_List) At(i int) Endpoint { return Endpoint(C.PointerList(s).At(i).ToStruct()) }
func (s Endpoint_List) ToArray() []Endpoint {
	n := s.Len()
	a := make([]Endpoint, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Endpoint_List) Set(i int, item Endpoint) { C.PointerList(s).Set(i, C.Object(item)) }

type Endpoint_Struct struct {
	Ip       []byte
	Port     int16
	Hostname string
}

func (s Endpoint) Struct() *Endpoint_Struct {
	t := &Endpoint_Struct{}
	t.Ip = s.Ip()
	t.Port = s.Port()
	t.Hostname = s.Hostname()
	return t
}
func (s Endpoint) LoadStruct(t *Endpoint_Struct) {
	if t == nil {
		return
	}
	s.SetIp(t.Ip)
	s.SetPort(t.Port)
	s.SetHostname(t.Hostname)
}
func (s *Endpoint_Struct) Copy() *Endpoint_Struct {
	t := &Endpoint_Struct{}
	t.Ip = s.Ip
	t.Port = s.Port
	t.Hostname = s.Hostname
	return t
}
func (s *Endpoint_Struct) Capnp(seg *C.Segment) Endpoint {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewEndpoint(seg)
	t.LoadStruct(s)
	return t
}
func (s *Endpoint_Struct) RootCapnp(seg *C.Segment) Endpoint {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootEndpoint(seg)
	t.LoadStruct(s)
	return t
}
func (s Endpoint) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"ip\":")
		if err != nil {
			return err
		}
		{
			s := s.Ip()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"port\":")
		if err != nil {
			return err
		}
		{
			s := s.Port()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"hostname\":")
		if err != nil {
			return err
		}
		{
			s := s.Hostname()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Endpoint) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Endpoint) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("ip = ")
	if err != nil {
		return err
	}
	{
		s := s.Ip()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("port = ")
	if err != nil {
		return err
	}
	{
		s := s.Port()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("hostname = ")
	if err != nil {
		return err
	}
	{
		s := s.Hostname()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Endpoint) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewEndpointFromCapLit(s *C.Segment, b []byte) (p Endpoint, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewEndpoint(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootEndpointFromCapLit(s *C.Segment, b []byte) (p Endpoint, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootEndpoint(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Endpoint) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["ip"]; ok {
		_ = fn
		var t []byte
		if temp, ok := fn.Val.(string); ok {
			t = []byte(temp)
		} else {
			return fmt.Errorf("expected '[]byte' but didn't matched")
		}
		_ = t
		s.SetIp(t)
	}
	if fn, ok := sv["port"]; ok {
		_ = fn
		var t int16
		if temp, ok := fn.Val.(int64); ok {
			t = int16(temp)
		} else {
			return fmt.Errorf("expected 'int16' but didn't matched")
		}
		_ = t
		s.SetPort(t)
	}
	if fn, ok := sv["hostname"]; ok {
		_ = fn
		t, ok := fn.Val.(string)
		if !ok {
			return fmt.Errorf("expected 'string' but didn't matched")
		}
		_ = t
		s.SetHostname(t)
	}
	return err
}
func (s Endpoint_List) FilterIndex(f func(i int, x Endpoint) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Endpoint_List) Each(f func(i int, x Endpoint) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Endpoint_List) Find(f func(i int, x Endpoint) bool) (Endpoint, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Endpoint{}, false
}
func (s Endpoint) Seg() *C.Segment {
	return s.Segment
}
func (s Endpoint) LitName() string {
	return "Endpoint"
}

type VoidUnion C.Struct
type VoidUnion_Which uint16

const (
	VOIDUNION_A VoidUnion_Which = 0
	VOIDUNION_B VoidUnion_Which = 1
)

func NewVoidUnion(s *C.Segment) VoidUnion      { return VoidUnion(s.NewStruct(8, 0)) }
func NewRootVoidUnion(s *C.Segment) VoidUnion  { return VoidUnion(s.NewRootStruct(8, 0)) }
func AutoNewVoidUnion(s *C.Segment) VoidUnion  { return VoidUnion(s.NewStructAR(8, 0)) }
func ReadRootVoidUnion(s *C.Segment) VoidUnion { return VoidUnion(s.Root(0).ToStruct()) }
func (s VoidUnion) Which() VoidUnion_Which     { return VoidUnion_Which(C.Struct(s).Get16(0)) }
func (s VoidUnion) SetA()                      { C.Struct(s).Set16(0, 0) }
func (s VoidUnion) SetB()                      { C.Struct(s).Set16(0, 1) }

type VoidUnion_List C.PointerList

func NewVoidUnionList(s *C.Segment, sz int) VoidUnion_List {
	return VoidUnion_List(s.NewCompositeList(8, 0, sz))
}
func (s VoidUnion_List) Len() int           { return C.PointerList(s).Len() }
func (s VoidUnion_List) At(i int) VoidUnion { return VoidUnion(C.PointerList(s).At(i).ToStruct()) }
func (s VoidUnion_List) ToArray() []VoidUnion {
	n := s.Len()
	a := make([]VoidUnion, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s VoidUnion_List) Set(i int, item VoidUnion) { C.PointerList(s).Set(i, C.Object(item)) }

type VoidUnion_Struct struct {
	Which VoidUnion_Which
}

func (s VoidUnion) Struct() *VoidUnion_Struct {
	t := &VoidUnion_Struct{}
	t.Which = s.Which()
	return t
}
func (s VoidUnion) LoadStruct(t *VoidUnion_Struct) {
	if t == nil {
		return
	}
	if t.Which == VOIDUNION_A {
		s.SetA()
	}
	if t.Which == VOIDUNION_B {
		s.SetB()
	}
}
func (s *VoidUnion_Struct) Copy() *VoidUnion_Struct {
	t := &VoidUnion_Struct{}
	t.Which = s.Which
	return t
}
func (s *VoidUnion_Struct) Capnp(seg *C.Segment) VoidUnion {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewVoidUnion(seg)
	t.LoadStruct(s)
	return t
}
func (s *VoidUnion_Struct) RootCapnp(seg *C.Segment) VoidUnion {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootVoidUnion(seg)
	t.LoadStruct(s)
	return t
}
func (s VoidUnion) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if s.Which() == VOIDUNION_A {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"a\":")
			if err != nil {
				return err
			}
			_ = s
			_, err = b.WriteString("null")
			if err != nil {
				return err
			}
		}
		if s.Which() == VOIDUNION_B {
			if !isFirstField {
				err = b.WriteByte(',')
			}
			isFirstField = false
			if err != nil {
				return err
			}
			_, err = b.WriteString("\"b\":")
			if err != nil {
				return err
			}
			_ = s
			_, err = b.WriteString("null")
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VoidUnion) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s VoidUnion) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	if s.Which() == VOIDUNION_A {
		_, err = b.WriteString("a = ")
		if err != nil {
			return err
		}
		_ = s
		_, err = b.WriteString("null")
		if err != nil {
			return err
		}
	}
	if s.Which() == VOIDUNION_B {
		_, err = b.WriteString("b = ")
		if err != nil {
			return err
		}
		_ = s
		_, err = b.WriteString("null")
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s VoidUnion) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewVoidUnionFromCapLit(s *C.Segment, b []byte) (p VoidUnion, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewVoidUnion(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootVoidUnionFromCapLit(s *C.Segment, b []byte) (p VoidUnion, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootVoidUnion(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s VoidUnion) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["a"]; ok {
		_ = fn
		s.SetA()
	}
	if fn, ok := sv["b"]; ok {
		_ = fn
		s.SetB()
	}
	return err
}
func (s VoidUnion_List) FilterIndex(f func(i int, x VoidUnion) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s VoidUnion_List) Each(f func(i int, x VoidUnion) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s VoidUnion_List) Find(f func(i int, x VoidUnion) bool) (VoidUnion, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return VoidUnion{}, false
}
func (s VoidUnion) Seg() *C.Segment {
	return s.Segment
}
func (s VoidUnion) LitName() string {
	return "VoidUnion"
}

type Nester1Capn C.Struct

func NewNester1Capn(s *C.Segment) Nester1Capn      { return Nester1Capn(s.NewStruct(0, 1)) }
func NewRootNester1Capn(s *C.Segment) Nester1Capn  { return Nester1Capn(s.NewRootStruct(0, 1)) }
func AutoNewNester1Capn(s *C.Segment) Nester1Capn  { return Nester1Capn(s.NewStructAR(0, 1)) }
func ReadRootNester1Capn(s *C.Segment) Nester1Capn { return Nester1Capn(s.Root(0).ToStruct()) }
func (s Nester1Capn) Strs() C.TextList             { return C.TextList(C.Struct(s).GetObject(0)) }
func (s Nester1Capn) SetStrs(v C.TextList)         { C.Struct(s).SetObject(0, C.Object(v)) }

type Nester1Capn_List C.PointerList

func NewNester1CapnList(s *C.Segment, sz int) Nester1Capn_List {
	return Nester1Capn_List(s.NewCompositeList(0, 1, sz))
}
func (s Nester1Capn_List) Len() int { return C.PointerList(s).Len() }
func (s Nester1Capn_List) At(i int) Nester1Capn {
	return Nester1Capn(C.PointerList(s).At(i).ToStruct())
}
func (s Nester1Capn_List) ToArray() []Nester1Capn {
	n := s.Len()
	a := make([]Nester1Capn, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s Nester1Capn_List) Set(i int, item Nester1Capn) { C.PointerList(s).Set(i, C.Object(item)) }

type Nester1Capn_Struct struct {
	Strs []string
}

func (s Nester1Capn) Struct() *Nester1Capn_Struct {
	t := &Nester1Capn_Struct{}
	for i := 0; i < s.Strs().Len(); i++ {
		t.Strs = append(t.Strs, s.Strs().At(i))
	}
	return t
}
func (s Nester1Capn) LoadStruct(t *Nester1Capn_Struct) {
	if t == nil {
		return
	}
	s.SetStrs(s.Segment.NewTextList(len(t.Strs)))
	for i := 0; i < len(t.Strs); i++ {
		s.Strs().Set(i, t.Strs[i])
	}
}
func (s *Nester1Capn_Struct) Copy() *Nester1Capn_Struct {
	t := &Nester1Capn_Struct{}
	for _, e := range s.Strs {
		t.Strs = append(t.Strs, e)
	}
	return t
}
func (s *Nester1Capn_Struct) Capnp(seg *C.Segment) Nester1Capn {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewNester1Capn(seg)
	t.LoadStruct(s)
	return t
}
func (s *Nester1Capn_Struct) RootCapnp(seg *C.Segment) Nester1Capn {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootNester1Capn(seg)
	t.LoadStruct(s)
	return t
}
func (s Nester1Capn) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"strs\":")
		if err != nil {
			return err
		}
		{
			s := s.Strs()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					buf, err = json.Marshal(s)
					if err != nil {
						return err
					}
					_, err = b.Write(buf)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Nester1Capn) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s Nester1Capn) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("strs = ")
	if err != nil {
		return err
	}
	{
		s := s.Strs()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				buf, err = json.Marshal(s)
				if err != nil {
					return err
				}
				_, err = b.Write(buf)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s Nester1Capn) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewNester1CapnFromCapLit(s *C.Segment, b []byte) (p Nester1Capn, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewNester1Capn(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootNester1CapnFromCapLit(s *C.Segment, b []byte) (p Nester1Capn, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootNester1Capn(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s Nester1Capn) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["strs"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := s.Segment.NewTextList(len(lv))
		for i, en := range lv {
			_ = en
			ev, ok := en.Val.(string)
			if !ok {
				return fmt.Errorf("expected 'string' but didn't matched")
			}
			_ = ev
			t.Set(i, ev)
		}
		s.SetStrs(t)
	}
	return err
}
func (s Nester1Capn_List) FilterIndex(f func(i int, x Nester1Capn) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s Nester1Capn_List) Each(f func(i int, x Nester1Capn) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s Nester1Capn_List) Find(f func(i int, x Nester1Capn) bool) (Nester1Capn, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return Nester1Capn{}, false
}
func (s Nester1Capn) Seg() *C.Segment {
	return s.Segment
}
func (s Nester1Capn) LitName() string {
	return "Nester1Capn"
}

type RWTestCapn C.Struct

func NewRWTestCapn(s *C.Segment) RWTestCapn        { return RWTestCapn(s.NewStruct(0, 1)) }
func NewRootRWTestCapn(s *C.Segment) RWTestCapn    { return RWTestCapn(s.NewRootStruct(0, 1)) }
func AutoNewRWTestCapn(s *C.Segment) RWTestCapn    { return RWTestCapn(s.NewStructAR(0, 1)) }
func ReadRootRWTestCapn(s *C.Segment) RWTestCapn   { return RWTestCapn(s.Root(0).ToStruct()) }
func (s RWTestCapn) NestMatrix() C.PointerList     { return C.PointerList(C.Struct(s).GetObject(0)) }
func (s RWTestCapn) SetNestMatrix(v C.PointerList) { C.Struct(s).SetObject(0, C.Object(v)) }

type RWTestCapn_List C.PointerList

func NewRWTestCapnList(s *C.Segment, sz int) RWTestCapn_List {
	return RWTestCapn_List(s.NewCompositeList(0, 1, sz))
}
func (s RWTestCapn_List) Len() int            { return C.PointerList(s).Len() }
func (s RWTestCapn_List) At(i int) RWTestCapn { return RWTestCapn(C.PointerList(s).At(i).ToStruct()) }
func (s RWTestCapn_List) ToArray() []RWTestCapn {
	n := s.Len()
	a := make([]RWTestCapn, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s RWTestCapn_List) Set(i int, item RWTestCapn) { C.PointerList(s).Set(i, C.Object(item)) }

type RWTestCapn_Struct struct {
	NestMatrix [][]*Nester1Capn_Struct
}

func (s RWTestCapn) Struct() *RWTestCapn_Struct {
	t := &RWTestCapn_Struct{}
	for i := 0; i < s.NestMatrix().Len(); i++ {
		t.NestMatrix = nil
		panic("List of List not supported now")
	}
	return t
}
func (s RWTestCapn) LoadStruct(t *RWTestCapn_Struct) {
	if t == nil {
		return
	}
	s.SetNestMatrix(s.Segment.NewPointerList(len(t.NestMatrix)))
	for i := 0; i < len(t.NestMatrix); i++ {
		panic("List of List not supported now")
	}
}
func (s *RWTestCapn_Struct) Copy() *RWTestCapn_Struct {
	t := &RWTestCapn_Struct{}
	for _, e := range s.NestMatrix {
		t.NestMatrix = append(t.NestMatrix, e)
	}
	return t
}
func (s *RWTestCapn_Struct) Capnp(seg *C.Segment) RWTestCapn {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRWTestCapn(seg)
	t.LoadStruct(s)
	return t
}
func (s *RWTestCapn_Struct) RootCapnp(seg *C.Segment) RWTestCapn {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootRWTestCapn(seg)
	t.LoadStruct(s)
	return t
}
func (s RWTestCapn) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"nestMatrix\":")
		if err != nil {
			return err
		}
		{
			s := s.NestMatrix()
			_ = s
			_, err = b.WriteString("\"untyped list\"")
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s RWTestCapn) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s RWTestCapn) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("nestMatrix = ")
	if err != nil {
		return err
	}
	{
		s := s.NestMatrix()
		_ = s
		_, err = b.WriteString("\"untyped list\"")
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s RWTestCapn) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewRWTestCapnFromCapLit(s *C.Segment, b []byte) (p RWTestCapn, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRWTestCapn(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootRWTestCapnFromCapLit(s *C.Segment, b []byte) (p RWTestCapn, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootRWTestCapn(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s RWTestCapn) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["nestMatrix"]; ok {
		_ = fn
		t := C.PointerList{}
		panic("in RWTestCapn, list of list' or 'list of pointer' is not supported")
		s.SetNestMatrix(t)
	}
	return err
}
func (s RWTestCapn_List) FilterIndex(f func(i int, x RWTestCapn) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s RWTestCapn_List) Each(f func(i int, x RWTestCapn) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s RWTestCapn_List) Find(f func(i int, x RWTestCapn) bool) (RWTestCapn, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return RWTestCapn{}, false
}
func (s RWTestCapn) Seg() *C.Segment {
	return s.Segment
}
func (s RWTestCapn) LitName() string {
	return "RWTestCapn"
}

type ListStructCapn C.Struct

func NewListStructCapn(s *C.Segment) ListStructCapn      { return ListStructCapn(s.NewStruct(0, 1)) }
func NewRootListStructCapn(s *C.Segment) ListStructCapn  { return ListStructCapn(s.NewRootStruct(0, 1)) }
func AutoNewListStructCapn(s *C.Segment) ListStructCapn  { return ListStructCapn(s.NewStructAR(0, 1)) }
func ReadRootListStructCapn(s *C.Segment) ListStructCapn { return ListStructCapn(s.Root(0).ToStruct()) }
func (s ListStructCapn) Vec() Nester1Capn_List           { return Nester1Capn_List(C.Struct(s).GetObject(0)) }
func (s ListStructCapn) SetVec(v Nester1Capn_List)       { C.Struct(s).SetObject(0, C.Object(v)) }

type ListStructCapn_List C.PointerList

func NewListStructCapnList(s *C.Segment, sz int) ListStructCapn_List {
	return ListStructCapn_List(s.NewCompositeList(0, 1, sz))
}
func (s ListStructCapn_List) Len() int { return C.PointerList(s).Len() }
func (s ListStructCapn_List) At(i int) ListStructCapn {
	return ListStructCapn(C.PointerList(s).At(i).ToStruct())
}
func (s ListStructCapn_List) ToArray() []ListStructCapn {
	n := s.Len()
	a := make([]ListStructCapn, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s ListStructCapn_List) Set(i int, item ListStructCapn) { C.PointerList(s).Set(i, C.Object(item)) }

type ListStructCapn_Struct struct {
	Vec []*Nester1Capn_Struct
}

func (s ListStructCapn) Struct() *ListStructCapn_Struct {
	t := &ListStructCapn_Struct{}
	for i := 0; i < s.Vec().Len(); i++ {
		elem := s.Vec().At(i).Struct()
		t.Vec = append(t.Vec, elem)
	}
	return t
}
func (s ListStructCapn) LoadStruct(t *ListStructCapn_Struct) {
	if t == nil {
		return
	}
	s.SetVec(NewNester1CapnList(s.Segment, len(t.Vec)))
	for i := 0; i < len(t.Vec); i++ {
		s.Vec().Set(i, t.Vec[i].Capnp(s.Segment))
	}
}
func (s *ListStructCapn_Struct) Copy() *ListStructCapn_Struct {
	t := &ListStructCapn_Struct{}
	for _, e := range s.Vec {
		if e != nil {
			t.Vec = append(t.Vec, e.Copy())
		} else {
			t.Vec = append(t.Vec, nil)
		}
	}
	return t
}
func (s *ListStructCapn_Struct) Capnp(seg *C.Segment) ListStructCapn {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewListStructCapn(seg)
	t.LoadStruct(s)
	return t
}
func (s *ListStructCapn_Struct) RootCapnp(seg *C.Segment) ListStructCapn {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootListStructCapn(seg)
	t.LoadStruct(s)
	return t
}
func (s ListStructCapn) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"vec\":")
		if err != nil {
			return err
		}
		{
			s := s.Vec()
			{
				err = b.WriteByte('[')
				if err != nil {
					return err
				}
				for i, s := range s.ToArray() {
					if i != 0 {
						_, err = b.WriteString(", ")
					}
					if err != nil {
						return err
					}
					err = s.WriteJSON(b)
					if err != nil {
						return err
					}
				}
				err = b.WriteByte(']')
			}
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s ListStructCapn) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s ListStructCapn) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("vec = ")
	if err != nil {
		return err
	}
	{
		s := s.Vec()
		{
			err = b.WriteByte('[')
			if err != nil {
				return err
			}
			for i, s := range s.ToArray() {
				if i != 0 {
					_, err = b.WriteString(", ")
				}
				if err != nil {
					return err
				}
				err = s.WriteCapLit(b)
				if err != nil {
					return err
				}
			}
			err = b.WriteByte(']')
		}
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s ListStructCapn) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewListStructCapnFromCapLit(s *C.Segment, b []byte) (p ListStructCapn, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewListStructCapn(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootListStructCapnFromCapLit(s *C.Segment, b []byte) (p ListStructCapn, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootListStructCapn(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s ListStructCapn) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["vec"]; ok {
		_ = fn
		lv := fn.Val.([]*C.CapLitNode)
		t := NewNester1CapnList(s.Segment, len(lv))
		for i, en := range lv {
			_ = en
			ev := NewNester1Capn(s.Segment)
			err := ev.UnmarshalCapLitNode(en)
			if err != nil {
				return err
			}
			t.Set(i, ev)
		}
		s.SetVec(t)
	}
	return err
}
func (s ListStructCapn_List) FilterIndex(f func(i int, x ListStructCapn) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s ListStructCapn_List) Each(f func(i int, x ListStructCapn) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s ListStructCapn_List) Find(f func(i int, x ListStructCapn) bool) (ListStructCapn, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return ListStructCapn{}, false
}
func (s ListStructCapn) Seg() *C.Segment {
	return s.Segment
}
func (s ListStructCapn) LitName() string {
	return "ListStructCapn"
}

type StackingRoot C.Struct

func NewStackingRoot(s *C.Segment) StackingRoot      { return StackingRoot(s.NewStruct(0, 2)) }
func NewRootStackingRoot(s *C.Segment) StackingRoot  { return StackingRoot(s.NewRootStruct(0, 2)) }
func AutoNewStackingRoot(s *C.Segment) StackingRoot  { return StackingRoot(s.NewStructAR(0, 2)) }
func ReadRootStackingRoot(s *C.Segment) StackingRoot { return StackingRoot(s.Root(0).ToStruct()) }
func (s StackingRoot) A() StackingA                  { return StackingA(C.Struct(s).GetObject(1).ToStruct()) }
func (s StackingRoot) SetA(v StackingA)              { C.Struct(s).SetObject(1, C.Object(v)) }
func (s StackingRoot) AWithDefault() StackingA {
	return StackingA(C.Struct(s).GetObject(0).ToStructDefault(x_832bcc6686a26d56, 0))
}
func (s StackingRoot) SetAWithDefault(v StackingA) { C.Struct(s).SetObject(0, C.Object(v)) }

type StackingRoot_List C.PointerList

func NewStackingRootList(s *C.Segment, sz int) StackingRoot_List {
	return StackingRoot_List(s.NewCompositeList(0, 2, sz))
}
func (s StackingRoot_List) Len() int { return C.PointerList(s).Len() }
func (s StackingRoot_List) At(i int) StackingRoot {
	return StackingRoot(C.PointerList(s).At(i).ToStruct())
}
func (s StackingRoot_List) ToArray() []StackingRoot {
	n := s.Len()
	a := make([]StackingRoot, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s StackingRoot_List) Set(i int, item StackingRoot) { C.PointerList(s).Set(i, C.Object(item)) }

type StackingRoot_Struct struct {
	A            *StackingA_Struct
	AWithDefault *StackingA_Struct
}

func (s StackingRoot) Struct() *StackingRoot_Struct {
	t := &StackingRoot_Struct{}
	{
		t.A = s.A().Struct()
	}
	{
		t.AWithDefault = s.AWithDefault().Struct()
	}
	return t
}
func (s StackingRoot) LoadStruct(t *StackingRoot_Struct) {
	if t == nil {
		return
	}
	{
		p := NewStackingA(s.Segment)
		p.LoadStruct(t.A)
		s.SetA(p)
	}
	{
		p := NewStackingA(s.Segment)
		p.LoadStruct(t.AWithDefault)
		s.SetAWithDefault(p)
	}
}
func (s *StackingRoot_Struct) Copy() *StackingRoot_Struct {
	t := &StackingRoot_Struct{}
	if s.A != nil {
		t.A = s.A.Copy()
	}
	if s.AWithDefault != nil {
		t.AWithDefault = s.AWithDefault.Copy()
	}
	return t
}
func (s *StackingRoot_Struct) Capnp(seg *C.Segment) StackingRoot {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewStackingRoot(seg)
	t.LoadStruct(s)
	return t
}
func (s *StackingRoot_Struct) RootCapnp(seg *C.Segment) StackingRoot {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootStackingRoot(seg)
	t.LoadStruct(s)
	return t
}
func (s StackingRoot) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"a\":")
		if err != nil {
			return err
		}
		{
			s := s.A()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"aWithDefault\":")
		if err != nil {
			return err
		}
		{
			s := s.AWithDefault()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s StackingRoot) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s StackingRoot) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("a = ")
	if err != nil {
		return err
	}
	{
		s := s.A()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("aWithDefault = ")
	if err != nil {
		return err
	}
	{
		s := s.AWithDefault()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s StackingRoot) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewStackingRootFromCapLit(s *C.Segment, b []byte) (p StackingRoot, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewStackingRoot(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootStackingRootFromCapLit(s *C.Segment, b []byte) (p StackingRoot, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootStackingRoot(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s StackingRoot) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["a"]; ok {
		_ = fn
		t := NewStackingA(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetA(t)
	}
	if fn, ok := sv["aWithDefault"]; ok {
		_ = fn
		t := NewStackingA(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetAWithDefault(t)
	}
	return err
}
func (s StackingRoot_List) FilterIndex(f func(i int, x StackingRoot) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s StackingRoot_List) Each(f func(i int, x StackingRoot) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s StackingRoot_List) Find(f func(i int, x StackingRoot) bool) (StackingRoot, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return StackingRoot{}, false
}
func (s StackingRoot) Seg() *C.Segment {
	return s.Segment
}
func (s StackingRoot) LitName() string {
	return "StackingRoot"
}

type StackingA C.Struct

func NewStackingA(s *C.Segment) StackingA      { return StackingA(s.NewStruct(8, 1)) }
func NewRootStackingA(s *C.Segment) StackingA  { return StackingA(s.NewRootStruct(8, 1)) }
func AutoNewStackingA(s *C.Segment) StackingA  { return StackingA(s.NewStructAR(8, 1)) }
func ReadRootStackingA(s *C.Segment) StackingA { return StackingA(s.Root(0).ToStruct()) }
func (s StackingA) Num() int32                 { return int32(C.Struct(s).Get32(0)) }
func (s StackingA) SetNum(v int32)             { C.Struct(s).Set32(0, uint32(v)) }
func (s StackingA) B() StackingB               { return StackingB(C.Struct(s).GetObject(0).ToStruct()) }
func (s StackingA) SetB(v StackingB)           { C.Struct(s).SetObject(0, C.Object(v)) }

type StackingA_List C.PointerList

func NewStackingAList(s *C.Segment, sz int) StackingA_List {
	return StackingA_List(s.NewCompositeList(8, 1, sz))
}
func (s StackingA_List) Len() int           { return C.PointerList(s).Len() }
func (s StackingA_List) At(i int) StackingA { return StackingA(C.PointerList(s).At(i).ToStruct()) }
func (s StackingA_List) ToArray() []StackingA {
	n := s.Len()
	a := make([]StackingA, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s StackingA_List) Set(i int, item StackingA) { C.PointerList(s).Set(i, C.Object(item)) }

type StackingA_Struct struct {
	Num int32
	B   *StackingB_Struct
}

func (s StackingA) Struct() *StackingA_Struct {
	t := &StackingA_Struct{}
	t.Num = s.Num()
	{
		t.B = s.B().Struct()
	}
	return t
}
func (s StackingA) LoadStruct(t *StackingA_Struct) {
	if t == nil {
		return
	}
	s.SetNum(t.Num)
	{
		p := NewStackingB(s.Segment)
		p.LoadStruct(t.B)
		s.SetB(p)
	}
}
func (s *StackingA_Struct) Copy() *StackingA_Struct {
	t := &StackingA_Struct{}
	t.Num = s.Num
	if s.B != nil {
		t.B = s.B.Copy()
	}
	return t
}
func (s *StackingA_Struct) Capnp(seg *C.Segment) StackingA {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewStackingA(seg)
	t.LoadStruct(s)
	return t
}
func (s *StackingA_Struct) RootCapnp(seg *C.Segment) StackingA {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootStackingA(seg)
	t.LoadStruct(s)
	return t
}
func (s StackingA) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"num\":")
		if err != nil {
			return err
		}
		{
			s := s.Num()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"b\":")
		if err != nil {
			return err
		}
		{
			s := s.B()
			err = s.WriteJSON(b)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s StackingA) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s StackingA) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("num = ")
	if err != nil {
		return err
	}
	{
		s := s.Num()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	_, err = b.WriteString(", ")
	if err != nil {
		return err
	}
	_, err = b.WriteString("b = ")
	if err != nil {
		return err
	}
	{
		s := s.B()
		err = s.WriteCapLit(b)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s StackingA) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewStackingAFromCapLit(s *C.Segment, b []byte) (p StackingA, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewStackingA(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootStackingAFromCapLit(s *C.Segment, b []byte) (p StackingA, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootStackingA(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s StackingA) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["num"]; ok {
		_ = fn
		var t int32
		if temp, ok := fn.Val.(int64); ok {
			t = int32(temp)
		} else {
			return fmt.Errorf("expected 'int32' but didn't matched")
		}
		_ = t
		s.SetNum(t)
	}
	if fn, ok := sv["b"]; ok {
		_ = fn
		t := NewStackingB(s.Segment)
		err := t.UnmarshalCapLitNode(fn)
		if err != nil {
			return err
		}
		s.SetB(t)
	}
	return err
}
func (s StackingA_List) FilterIndex(f func(i int, x StackingA) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s StackingA_List) Each(f func(i int, x StackingA) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s StackingA_List) Find(f func(i int, x StackingA) bool) (StackingA, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return StackingA{}, false
}
func (s StackingA) Seg() *C.Segment {
	return s.Segment
}
func (s StackingA) LitName() string {
	return "StackingA"
}

type StackingB C.Struct

func NewStackingB(s *C.Segment) StackingB      { return StackingB(s.NewStruct(8, 0)) }
func NewRootStackingB(s *C.Segment) StackingB  { return StackingB(s.NewRootStruct(8, 0)) }
func AutoNewStackingB(s *C.Segment) StackingB  { return StackingB(s.NewStructAR(8, 0)) }
func ReadRootStackingB(s *C.Segment) StackingB { return StackingB(s.Root(0).ToStruct()) }
func (s StackingB) Num() int32                 { return int32(C.Struct(s).Get32(0)) }
func (s StackingB) SetNum(v int32)             { C.Struct(s).Set32(0, uint32(v)) }

type StackingB_List C.PointerList

func NewStackingBList(s *C.Segment, sz int) StackingB_List {
	return StackingB_List(s.NewCompositeList(8, 0, sz))
}
func (s StackingB_List) Len() int           { return C.PointerList(s).Len() }
func (s StackingB_List) At(i int) StackingB { return StackingB(C.PointerList(s).At(i).ToStruct()) }
func (s StackingB_List) ToArray() []StackingB {
	n := s.Len()
	a := make([]StackingB, n)
	for i := 0; i < n; i++ {
		a[i] = s.At(i)
	}
	return a
}
func (s StackingB_List) Set(i int, item StackingB) { C.PointerList(s).Set(i, C.Object(item)) }

type StackingB_Struct struct {
	Num int32
}

func (s StackingB) Struct() *StackingB_Struct {
	t := &StackingB_Struct{}
	t.Num = s.Num()
	return t
}
func (s StackingB) LoadStruct(t *StackingB_Struct) {
	if t == nil {
		return
	}
	s.SetNum(t.Num)
}
func (s *StackingB_Struct) Copy() *StackingB_Struct {
	t := &StackingB_Struct{}
	t.Num = s.Num
	return t
}
func (s *StackingB_Struct) Capnp(seg *C.Segment) StackingB {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewStackingB(seg)
	t.LoadStruct(s)
	return t
}
func (s *StackingB_Struct) RootCapnp(seg *C.Segment) StackingB {
	if seg == nil {
		seg = C.NewBuffer(nil)
	}
	t := NewRootStackingB(seg)
	t.LoadStruct(s)
	return t
}
func (s StackingB) WriteJSON(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('{')
	if err != nil {
		return err
	}
	{
		isFirstField := true
		_ = isFirstField
		if !isFirstField {
			err = b.WriteByte(',')
		}
		isFirstField = false
		if err != nil {
			return err
		}
		_, err = b.WriteString("\"num\":")
		if err != nil {
			return err
		}
		{
			s := s.Num()
			buf, err = json.Marshal(s)
			if err != nil {
				return err
			}
			_, err = b.Write(buf)
			if err != nil {
				return err
			}
		}
		err = b.WriteByte('}')
	}
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s StackingB) MarshalJSON() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteJSON(&b)
	return b.Bytes(), err
}
func (s StackingB) WriteCapLit(w io.Writer) error {
	b := bufio.NewWriter(w)
	var err error
	var buf []byte
	_ = buf
	err = b.WriteByte('(')
	if err != nil {
		return err
	}
	_, err = b.WriteString("num = ")
	if err != nil {
		return err
	}
	{
		s := s.Num()
		buf, err = json.Marshal(s)
		if err != nil {
			return err
		}
		_, err = b.Write(buf)
		if err != nil {
			return err
		}
	}
	err = b.WriteByte(')')
	if err != nil {
		return err
	}
	err = b.Flush()
	return err
}
func (s StackingB) MarshalCapLit() ([]byte, error) {
	b := bytes.Buffer{}
	err := s.WriteCapLit(&b)
	return b.Bytes(), err
}
func NewStackingBFromCapLit(s *C.Segment, b []byte) (p StackingB, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewStackingB(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func NewRootStackingBFromCapLit(s *C.Segment, b []byte) (p StackingB, err error) {
	n, err := C.ParseCapLit(b)
	if err != nil {
		return
	}
	p = NewRootStackingB(s)
	err = p.UnmarshalCapLitNode(n)
	return
}
func (s StackingB) UnmarshalCapLitNode(n *C.CapLitNode) error {
	var err error
	sv, ok := n.Val.(map[string]*C.CapLitNode)
	if !ok {
		return fmt.Errorf("expected 'map[string]*C.CapLitNode' but didn't matched")
	}
	_ = sv
	if fn, ok := sv["num"]; ok {
		_ = fn
		var t int32
		if temp, ok := fn.Val.(int64); ok {
			t = int32(temp)
		} else {
			return fmt.Errorf("expected 'int32' but didn't matched")
		}
		_ = t
		s.SetNum(t)
	}
	return err
}
func (s StackingB_List) FilterIndex(f func(i int, x StackingB) bool) []int {
	filtered := make([]int, 0)
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			filtered = append(filtered, i)
		}
	}
	return filtered
}
func (s StackingB_List) Each(f func(i int, x StackingB) error) error {
	for i := 0; i < s.Len(); i++ {
		err := f(i, s.At(i))
		if err != nil {
			return err
		}
	}
	return nil
}
func (s StackingB_List) Find(f func(i int, x StackingB) bool) (StackingB, bool) {
	for i := 0; i < s.Len(); i++ {
		if f(i, s.At(i)) {
			return s.At(i), true
		}
	}
	return StackingB{}, false
}
func (s StackingB) Seg() *C.Segment {
	return s.Segment
}
func (s StackingB) LitName() string {
	return "StackingB"
}

var x_832bcc6686a26d56 = C.NewBuffer([]byte{
	0, 0, 0, 0, 1, 0, 1, 0,
	42, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
})
